#!/usr/bin/python3 -u

import argparse
import re
import datetime
import subprocess
import os
import sys
import errno
import glob
import progressbar as pb
import shutil
import psutil
# sqlite3 is used for writing database about last runs - it is read by list and from gnome-extension (planned)
import sqlite3

try:
    from anytree import Node, RenderTree
    TREE=True
except:
    TREE=False

#from mksnapshotconfig import Config
from mkbackup_btrfs_config import Config

#define progress timer class
class progress_timer:

    def __init__(self, n_iter, description="Something"):
        self.n_iter         = n_iter
        self.iter           = 0
        self.description    = description + ': '
        self.timer          = None
        self.initialize()

    def initialize(self):
        #initialize timer
        widgets = [self.description, pb.Percentage(), ' ',   
                   pb.Bar(marker=pb.RotatingMarker()), ' ', pb.ETA()]
        self.timer = pb.ProgressBar(widgets=widgets, maxval=self.n_iter).start()

    def update(self, q=1):
        #update timer
        self.timer.update(self.iter)
        self.iter += q

    def finish(self):
        #end timer
        self.timer.finish()

# RuntimeError definitions:
# RuntimeError(msg, code)
# code:
# 0 - continue programm
# 1 - raise error

class create_db:
    def __init__(self, ts=0, db='/var/lib/mkbackup-btrfs'):
        if not os.path.exists(db):
            os.makedirs(db)
        print("DB",db)
        
        conn = sqlite3.connect(db+'/mkbackup-btrfs.db')
        conn.execute('''CREATE TABLE LASTRUN
            (ID INTEGER PRIMARY KEY NOT NULL,
            VOL     TEST,
            INTV    TEXT,
            LRUN      TEXT,
            LTRANS  TEXT,
            DELETED INTEGER);''')
        conn.execute('''CREATE TABLE JOURNAL
            (ID INTEGER PRIMARY KEY NOT NULL,
            VOL TEXT,
            INTNAME TEXT,
            SNAPNAME TEXT,
            SNAP_TS TEXT,
            TRNS_TS TEXT,
            DELETED INTEGER);''')
        conn.close()
    
if hasattr(os, 'sync'):
    sync = os.sync
else:
    import ctypes
    libc = ctypes.CDLL('libc.so.6')
    def sync():
        libc.sync()

def DEBUG(*msg,level=0,verbose=0):
    if verbose < level :
        return
    else: 
        #print(' '.join(msg))
        for i in msg: print(i)
        return

def sp_call(args,cmdl,level=4):
    stdout = subprocess.DEVNULL
    stderr = subprocess.DEVNULL
    stdout = args.stdout
    stderr = args.stderr
    
    DEBUG('[II][cmdl]  '+' '.join(cmdl),level=level,verbose=args.verbose)
    try:
        r = subprocess.call(cmdl, stdout=stdout, stderr=stderr)
    except subprocess.CalledProcessError as e:
        DEBUG(e,level=level,verbose=args.verbose)
        pass # handle errors in the called executable
    except OSError as e:
        DEBUG(e,level=level,verbose=args.verbose)
        raise SystemExit
        pass 
    return(r)
    
def isstring(s):
    # if we use Python 3
    if (sys.version_info[0] == 3):
        return isinstance(s, str)
    # we use Python 2
    return isinstance(s, basestring)

def check_lockfile(args,lf):
    # Returns True, when lockfile is in use, and False if lockfile is unused
    # Returns None, when lockfile is not existing
    if os.path.isfile(lf):
        file = open(lf, 'r')
        pid = file.readline()
        file.close()
        if len(pid) > 0 and os.path.isfile('/proc/'+pid+'/cmdline'):
            DEBUG('lockfile %s in use with process %s' % (lf,pid),level=3,verbose=args.verbose)
            return(True)
        else:
            DEBUG('lockfile %s unused' % (lf),level=3,verbose=args.verbose)
            return(False)
    else:
        DEBUG('lockfile %s not existing' % (lf),level=3,verbose=args.verbose)
        return(None)

class Stack:
    def __init__(self):
        self.item = []

    def push(self,item):
        self.item.append(item)

    def pop(self):
        return self.item.pop()

    def is_empty(self):
        return(self.item == [])


class Error(Exception):
    pass

class NoSubvolumeError(Error):
    def __init__(self):
        print("ERROR - Snapshot not found" )
    pass

class ScanFsError(Error):
    def __init__(self,vol='unknown'):
        print("ERROR - scanfs. Volume not found or no Permissions: %s"  % (vol))
        pass
    pass

class NoBtrfsVolumeError(Error):
    def __init__(self,vol='unknown'):
        #print("BlaERROR - Read systemvolume failed. Volume not found: %s"  % (vol))
        pass
    pass

class TransferError(Error):
    pass

class CreateError(Error):
    pass

class SetpropError(Error):
    pass

class DeleteError(Error):
    pass

class SystemVolumeError(Error):
    def __init__(self,action='undefined'):
        print("Action %s on Systemvolume not allowed" % (action))

class listing:
    what = "Listing of all subvolumes in store"
    #Lists = Stack()
    CreatedSubvolumes = Stack()
    DeletedSubvolumes = Stack()
    TransferedSubvolumes = Stack()



    def __init__(self,args,store='SRC',single=False):
        #listing.Lists.push(store)
        self.args      = args
        self.store     = store
        self.single    = single
        self.verbose   = args.verbose
        self.StoreList = store # List is from which store
        self.MountPath = args.config.getMountPath(self.store,self.args.tag,original=False) # path from / to the mountpoint of store
        self.StoreName = args.config.getStoreName(self.store,self.args.tag) # path of store below the mountpoint
        self.StorePath = args.config.getStorePath(self.store,self.args.tag) # whole path from / to directory where the snapshot lives
        self.BkpPath   = args.config.getStorePath('BKP',self.args.tag) # whole path from / to directory where the snapshot lives
        self.svols     = dict()
        self.args      = args
#        self.BKPLogin  = args.config.getSSHLogin(store='BKP',tag=self.args.tag)
#        self.SNPLogin  = args.config.getSSHLogin(store='SNP',tag=self.args.tag)
#        self.SRCLogin  = args.config.getSSHLogin(store='SRC',tag=self.args.tag)
        #print("LOGINS",self.SRCLogin,self.SNPLogin,self.BKPLogin)
        self.scanfs()

    def scanfs(self):
        DEBUG('SCAN btrfs-drive: %s' % (self.StorePath),level=3)
        if self.single:
            cmd=['btrfs','subvolume','list','-R','-u','-q','-c','-o',self.StorePath]
        else:
            cmd=['btrfs','subvolume','list','-R','-u','-q','-c',self.StorePath]

        try:
            res = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=self.args.stderr)
            output,error = res.communicate()
            if res.returncode > 0:
                #print('scanfs error',self.StorePath,output,error,res.returncode)
                raise ScanFsError(self.StorePath)
        except subprocess.CalledProcessError as e:
            raise ScanFsError(self.StorePath)
        except:
            raise
        #if output[0] == 0:
        for line in output.splitlines():
            argmts = str(line, encoding='utf8').split(' ')
            #ID 2412 gen 8547 cgen 8547 top level 2393 parent_uuid 7991115b-8a6b-6d4d-b664-03db01e902d0 received_uuid - uuid 368490e7-5aca-0d4d-9b7a-becff0487ebd path aldebaran/__ALWAYSCURRENT__.2016-10-15_22:40:25.hourly.part/var-spool-dovecot
            self.svols[argmts[1]] = dict() 
            self.svols[argmts[1]]['id'] = argmts[1]
            self.svols[argmts[1]]['gen'] = argmts[3]
            self.svols[argmts[1]]['cgen'] = argmts[5]
            self.svols[argmts[1]]['tlid'] = argmts[8]
            self.svols[argmts[1]]['puuid'] = argmts[10]
            self.svols[argmts[1]]['ruuid'] = argmts[12]
            self.svols[argmts[1]]['uuid'] = argmts[14]
            self.svols[argmts[1]]['path'] = ' '.join(argmts[16:])

    def DEBUG(self,*msg,level=0):
        if self.verbose >= level :
            for i in msg: print(i)
        return

    def _ret(self,ret,reverse=False):
        return(reversed(ret) if reverse else ret)

    def build_tree(self,snap=None,st="/"):
        if TREE:
            wood = Node(self.config.getStorePath(st,args.tag)+' ('+st+')')
            stroot="wood"
            isbkp = self.config.getStorePath(st,args.tag) == self.config.getStorePath('BKP',args.tag)
            for sub in sorted(self.svols.keys(),key=int):
                if self.svols[sub]['path'] == snap: stroot = self.svols[sub]['uuid']
                try:
                    vars()[str(self.svols[sub]['uuid'])] = Node(str(self.svols[sub]['path']),parent=vars()[self.svols[sub]['puuid']])
                except:
                    vars()[str(self.svols[sub]['uuid'])] = Node(str(self.svols[sub]['path']),parent=wood)

            for pre, fill, node in RenderTree(wood if snap == None else vars()[stroot]):
                print("%s%s" % (pre, node.name))
        else:
            print("""anytree is not available. Please ask your sysadmin to install anytree with 
            pip3 install anytree""")

    
    def list_sisters(self,ID,rev=False,older=None,younger=None,names=True):
        result = []
        if older   == None: older = self.args.older
        if younger == None: younger = self.args.younger
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['puuid'] == self.svols[ID]['puuid'] and not sub == ID:
                #print('XXX',self.svols[sub]['gen'],self.svols[ID]['gen'],self.svols[sub]['cgen'],self.svols[ID]['cgen'],self.svols[sub]['path'],self.svols[ID]['path'])
                if older:
                    if int(self.svols[sub]['cgen']) >= int(self.svols[ID]['cgen']): continue
                if younger:
                    if int(self.svols[sub]['cgen']) <= int(self.svols[ID]['cgen']): continue
                self.DEBUG('SISTER',self.svols[sub]['id'],self.svols[sub]['path'],level=5)
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def list_parent(self,puuid,rev=False,names=True):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['uuid'] == puuid:
                self.DEBUG('PARENT',self.svols[sub]['path'],level=5)
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def list_snapshots(self,uuid,rev=False,names=True):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['puuid'] == uuid:
                self.DEBUG('PARENTX',names,sub,self.svols[sub]['path'] if names else sub,"Y",level=5)
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def grep_volume(self,expr,names=True,rev=False):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if expr.search(self.svols[sub]['path']):
                self.DEBUG('REGEX',self.svols[sub]['path'],level=5)
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def grep_subvolumes(self,expr,names=True,rev=False):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if expr.search(self.svols[sub]['path']):
                self.DEBUG('REGEX',self.svols[sub]['path'],level=5)
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def _lssub(self,id):
        # recursiv listing of all subvolumes below a given snapshot
        result = []
        for i in self.svols:
            if self.svols[i]['tlid'] == id:
                result.append(self.svols[i]['id'])
                for i in self._lssub(self.svols[i]['id']):
                    result.append(i)
        return(result)

    def list_subvolumes(self,id,rev=False,names=True,incl_self=True):
        result= []
        first = '' if names else id 
        if incl_self: result.append(first)
        for sub in self._lssub(id):
            result.append(self.svols[sub]['path'].partition(self.svols[id]['path']+'/')[2]) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def get_oldest(self,ID,rev=False,older=None,younger=None,names=True):
        result = []
        if older   == None: older = self.args.older
        if younger == None: younger = self.args.younger
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['puuid'] == self.svols[ID]['puuid'] and not sub == ID:
                if older:
                    if self.svols[sub]['gen'] >= self.svols[ID]['gen']: continue
                if younger:
                    if self.svols[sub]['gen'] <= self.svols[ID]['gen']: continue
                self.DEBUG('SISTER',self.svols[sub]['id'],self.svols[sub]['path'],level=5)
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    
    def main(self):
        self.scanfs()

class SubVolumeInfo(listing):

    def __init__(self,args,name,store='SRC',single=False):
        super().__init__(args,store=store,single=single)
        if store    == 'SRC':
            self.SourceName  = os.path.basename(name.rstrip('/'))
        else:
            self.SourceName  = name.strip('/')
        self.vol          = name
        self.uuid         = '' #UUID
        self.puuid        = '' #Parent-UUID
        self.ruuid        = '' #Received UUID
        self.ctime        = '' #Creation Time
        self.id           = 0 #subvolume-ID
        self.gen          = 0 # Generation
        self.cgen         = 0 #Generation at creationtime
        self.pid          = 0 #Parent ID
        self.tlid         = 0 #Top level ID
        self.flags        = 0 #Flags
        self.snapshots    = [] #List of snapshots made from this subvolume
        self.translate={'Name':'SourceName',
                        'UUID':'uuid',
                        'Parent UUID':'puuid',
                        'Received UUID':'ruuid',
                        'Creation time':'ctime',
                        'Subvolume ID':'id',
                        'Generation':'gen',
                        'Gen at creation':'cgen',
                        'Parent ID':'pid',
                        'Top level ID':'tlid',
                        'Flags':'flags',
                        'Snapshot(s)':'snapshots'}
        #print('SubVolumeInfo',self.SourceName)
        self.parse_btrfs_show()

    def parse_btrfs_show(self):
        self.DEBUG('[II]  parse subvolume store<%s> %s' % (self.store,self.SourceName),level=2)
        subvolume_data = dict()
        if self.SourceName.startswith(self.StoreName):
            SourceName = re.sub(self.StoreName+'/','',self.SourceName)
        else:
            SourceName = self.SourceName
        cmd = ['btrfs','subvolume','show',self.StorePath+'/'+SourceName]
        sv = False
        snaps=[]
        try:
            res = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=self.args.stderr)
            output,error = res.communicate()
            if res.returncode > 0:
                raise NoSubvolumeError
        except:
            raise

        for line in output.splitlines():
            argmnts = [arg.strip() for arg in str(line, encoding='utf8').split(': ')]
            if len(argmnts) > 1:
                setattr(self, self.tr_att(argmnts[0]), argmnts[1])
            elif sv:
                snaps.append(argmnts[0])
            else:
                if argmnts[0] == 'Snapshot(s):': 
                    sv = True
                else:
                    self.path=argmnts[0]
        self.snapshots = snaps
        self.dir       = os.path.dirname(self.path)
        return


class SubVolume(SubVolumeInfo):
    # read Subclasses:  http://www.python-course.eu/python3_inheritance.php
    what = 'store all informations about a btrfs-Subvolume'

    def __init__(self,args,name,store='SRC',single=False):
        super().__init__(args,store=store,name=name,single=single)
        self.snapped      = False
        self.transferred  = False
        self.exist        = True

        self.args         = args
        self.timestamp    = args.timestamp 
        self.verbose      = args.verbose
        self.tag          = args.tag
        self.config       = args.config #Config()
        self.path         = ''
        self.dir          = ''
        self.basename     = os.path.basename(name.split('.')[0])
        if args.action == 'transfer':
            self.trans_ts     = name.split('.')[1]
            self.trans_tag    = name.split('.')[2]

        regexpart         = re.compile('\.part') 

        self.OrigName     = re.sub('\.part$','',self.SourceName)
        self.OrigLock     = self.OrigName+'.part'
        if args.action == 'transfer':
            self.OLockFile = '.'+self.basename+'.'+self.trans_ts+'.'+self.trans_tag+'.~lock'
        else:
            self.OLockFile    = '.'+self.OrigName+'.~lock' if args.action != 'transfer' else '.'+self.SourceName+'.~lock'
        self.SnapName     = self.basename+'.'+self.timestamp+'.'+self.tag
        self.SnapLock     = self.SnapName+'.part'
        self.SLockFile    = '.'+self.SnapName+'.~lock'
        self.SnapID       = None
        self.DEBUG('OrigName  ',self.OrigName,level=4)
        self.DEBUG('OrigName',self.OrigName,level=4)
        self.DEBUG('OrigLock  ',self.OrigLock,level=4)
        self.DEBUG('OLockFile ',self.OLockFile,level=4)
        self.DEBUG('SnapName  ',self.SnapName,level=4)
        self.DEBUG('SnapLock  ',self.SnapLock,level=4)
        self.DEBUG('SLockFile ',self.SLockFile,level=4)

        self.parent       = ''
        self.subvolsshort = []
        self.subvolumes   = []
        self.stderr       = args.stderr
        self.DEBUG('[II]  <%s> is %s: ' % (self.store, self.config.getStorePath(self.store,self.args.tag)),level=2)

    def _createlockfile(self,lf,ln):
        if os.path.isfile(self.store+'/'+lf):
            self.DEBUG('Nothing to lock',level=2)
        else:
            self.DEBUG("%-12s»<%s>/%s«" % (' =lock>',self.store,ln),level=0)
            try:
                lockfile = open(self.StorePath+'/'+lf, 'w', 1)
                lockfile.write(str(os.getpid()))
                lockfile.close()
            except OSError as e:
                print('ERROR create lockfile: %s' % (e))
                pass
        return

    def _deletelockfile(self,lf,ln,checked=True):
        path = self.StorePath+'/'
        if checked:
            if check_lockfile(self.args,path+lf):
                self.DEBUG('ERROR - lockfile in use: <%s - %s>/%s' % (self.store,self.StorePath,path+lf),level=2)
                return
        try:
            os.remove(path+lf)
        except OSError as e:
            if e.errno == errno.EEXIST or errno.ENOENT:
                pass 
                # if lockfile doesn't exist, continue 
                #self.DEBUG('INFO - lockfile is not existing: <%s - %s>/%s' % (self.store,self.StorePath,path+lf),level=2)
            else:
                raise e
        return


    def _rename(self,Action,From,To,store):
        for i in self.config.getVolumes():
            if From == i:
                raise RuntimeError('ERROR - Systemvolume not allowed to rename (From): %s' % (From),1)
            elif To == i:
                raise RuntimeError('ERROR - Systemvolume not allowed to rename (To): %s' % (To),1)

        st = self.store if store == None else store
        StorePath = self.config.getStorePath(st,self.args.tag)
        if not issubvol(self.args,StorePath,store): 
            self.DEBUG("Failed to rename »<%s>%s«, is no btrfs-subvolume, or not existing" % (st,From),level=3)
            return

        self.DEBUG(' =try-to-rename> »<%s>/%s« --> »%s«' % (st,From,To),level=3)
        pass

        self.DEBUG(" =unlock>  <%s>/%s" % (st,To),level=1)
        if os.path.exists(StorePath+'/'+To):
            self.DEBUG(' =%-10s»%s« exists. Nothing to rename' % (Action+':',To),level=3)
            return
        else:
            if self.args.action == 'create':
                if Action == 'lock':
                    self.DEBUG(" =%-11s nothing to rename" % (Action+':'),level=3)
                    return
            else:
                if issubvol(self.args,StorePath+'/'+From,store):
                    self.DEBUG(' =%s-rename> »<%s>/%s« --> %s' % (Action,st,From,To), level=1)  
                else: 
                    return
        try:
            os.rename(StorePath+'/'+From,StorePath+'/'+To)
        except FileNotFoundError:
            self.DEBUG('Nothing to rename',level=3)
        except OSError as e:
            print(e)
        except:
            raise
                
        return

    def lock(self,store=None):
        store = self.store
        self.DEBUG('try to lock on action %s' % (self.args.action),level=4)
        try:
            if self.args.action == 'create':
                self.DEBUG(' ++> create lockfile for Snapshot (%s)' % (self.args.action),level=3)
                self._createlockfile(self.SLockFile,self.SnapName)
                pass
            elif self.args.action == 'delete' or self.args.action == 'cleanup':
                self.DEBUG(' --> delete lockfile for Original (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.OLockFile,self.SourceName)
                self.DEBUG(' --> rename to OrigLock',level=3)
                self._rename('lock',self.SourceName,self.OrigLock,store)
                pass
            elif self.args.action == 'transfer':
                self.DEBUG(' --> create lockfile for Original (%s)' % (self.args.action),level=3)
                self._createlockfile(self.OLockFile,self.SourceName)
                self.DEBUG(' --> rename to OrigLock',level=3)
                self._rename('lock',self.SourceName,self.OrigLock,store)
                pass
            else:
                self.DEBUG(' ++> create lockfile for Snapshot (%s)' % (self.args.action),level=3)
                self._createlockfile(self.SLockFile,self.SnapName)
                self.DEBUG(' --> rename to SnapLock',level=3)
                self._rename('lock',self.SnapName,self.SnapLock,store)
                pass
        except RuntimeError as e:
            if e.args[1] > 0:
                raise e
        except:
            raise
        self.scanfs()
        return
        
    def unlock(self,checked=False,store=None):
        store = self.store
        self.DEBUG('try to unlock on action %s' % (self.args.action),level=4)
        try:
            if self.args.action == 'create':
                self.DEBUG(' --unlock-> %s' % (self.args.action),level=4)
                self.DEBUG(' --> delete lockfile from Snapshot (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.SLockFile,self.SnapName,checked=False)
                self.DEBUG(' --> rename to SnapName',level=3)
                self._rename('unlock',self.SnapLock,self.SnapName,store)
                self._rename('unlock',self.SnapLock,self.SnapName,'BKP')
                pass
            elif self.args.action == 'delete':
                self.DEBUG(' --> delete lockfile from Original (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.OLockFile,self.SourceName,checked=False)
                self.DEBUG(' --> rename to OrigName',level=3)
                self._rename('unlock',self.OrigLock,self.OrigName,store)
                pass
            elif self.args.action == 'transfer':
                self.DEBUG(' --> delete lockfile from Original (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.OLockFile,self.SourceName,checked=False)
                self.DEBUG(' --> (%s) rename to OrigName' % (self.args.action),level=3)
                self._rename('unlock',self.OrigLock,self.OrigName,store)
                self._rename('unlock',self.OrigLock,self.OrigName,'BKP')
                pass
            else:
                self.DEBUG(' --> delete lockfile from Snapshot (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.SLockFile,self.SnapName)
                self.DEBUG(' --> rename to SnapName',level=3)
                self._rename('unlock',self.SnapLock,self.SnapName,store)
                pass
        except Exception as e:
            DEBUG(e)
            raise e
        except:
            raise
        self.scanfs()
        return

#
    def tr_att(self,att):
        if att in self.translate:
            return self.translate[att]
        else:
            return att

    def setprop(self,ro=True):
        login = [] if self.config.getSSHLogin(self.store,self.tag) is None else self.config.getSSHLogin(self.store,self.tag).split(' ')
        if self.args.action == 'create':
            sname = self.SnapLock
        elif self.args.action == 'setprop': 
            sname = self.OrigName
        else:
            sname = self.OrigLock

        for i in self.config.getVolumes():
            if sname == i and ro == True:
                raise RuntimeError('ERROR - Systemvolume not allowed to set read-only: %s' % (sname),1)

        propn = 'ro' if ro else 'rw'
        prop = 'true' if ro else 'false'
        self.DEBUG(' =set-%-6s»<%s>/%s«' % (propn+'>',self.store,sname),level=1)
        for sub in self.list_subvolumes(self.id,names=True,rev=True if ro else False):
            if issubvol(self.args,self.StorePath+'/'+sname+'/'+sub,self.store):
                self.DEBUG('  =%-9s»<%s>/%s«' % (propn+'>',self.store,sname+'/'+sub),level=1)
                try:
                    cmd = login+['btrfs','property','set','-ts',self.StorePath+'/'+sname+'/'+sub,'ro',prop]
                    #cmd = ['btrfs','property','set','-ts',self.StorePath+'/'+sname+'/'+sub,'ro',prop]
                    #self.config.remotecommand(self.tag,self.store,cmd)
                    sp_call(self.args,cmd)
                except:
                    print('setprop error')
                    
            else:
                pass
                
    def create(self):
        self.DEBUG(' =create-snapshot=> from »<%s>/%s«' % (self.store, self.SourceName),level=1)
        #compile regular expression for ignoring subvolume-names
        if self.args.ignore == None:
            if not self.config.getIgnores(self.args.tag) == None:
                #print("XXX",self.config.getIgnores(self.args.tag).split(','))
                re_ign = re.compile('|'.join(self.config.getIgnores(self.args.tag).split(',')))
            else:
                re_ign = None
        else:
            re_ign = re.compile('|'.join(self.args.ignore))
        #print('IGNORES',re_ign)
        if self.args.npb: pt = progress_timer(description= ' =create-snapshot=> from »<%s>/%s«: ' % (self.store, self.SourceName), n_iter=len(self.list_subvolumes(self.id,names=True)))
        #if self.exist:
        if issubvol(self.args,self.StorePath+'/'+self.SourceName,self.store):
            try:
                for sub in self.list_subvolumes(self.id,names=True):
                    # Test if subvolume is in ignorelist - only debug-output now
                    if re_ign != None and re_ign.search('/'+sub):
                        self.DEBUG('%-12s»<%s>/%s«:' % (' -IGNORE->',self.store, sub),level=2)
                    else:
                        #print('/'+sub,re_ign,re_ign.search('/'+sub))
                        # Test the Source for local snapshotting
                        if issubvol(self.args,self.StorePath+'/'+self.SourceName+'/'+sub,self.store):
                            dest = self.SnapLock+'/'+sub
                            #TODO: Test on ignores
                            cmd = ['btrfs','subvolume','snapshot',self.StorePath+'/'+self.SourceName+'/'+sub,self.StorePath+'/'+dest]

                            # Test the destination for local snapshotting
                            if issubvol(self.args,self.StorePath+'/'+dest,self.store):
                                # Test if top level snapshot is existing and a snapshot
                                raise RuntimeError('FAILURE - Destination exists: %s' % (self.StorePath+'/'+dest), 0)
                            elif issubvol(self.args,self.StorePath+'/'+dest,self.store) == False:
                                # If destination exists and is a directory and not a snapshot, delete dir and create snapshot (for subvolumes of snapshot)
                                self.DEBUG('%-12s»<%s>/%s«' % (' =create>',self.store,dest),level=1)
                                sp_call(self.args,['rm','-r','-f',self.StorePath+'/'+dest])
                                sp_call(self.args,cmd)                           
                            else:
                                # If destination doesnt exist, create the snapshot
                                self.DEBUG('%-12s»<%s>/%s«' % (' =create>',self.store,dest),level=1)
                                sp_call(self.args,cmd)                           
                            sync()

                        elif issubvol(self.args,self.OrigName+'/'+sub,self.store) == False:
                            raise RuntimeError('FAILURE - Source is directory, not a subvolume. No creation possible: %s' % (sub), 0)
                        else:
                            self.DEBUG( " Source-subvolume not existing: %s" % (self.OrigName+'/'+sub),level=3)
                    if self.args.npb: pt.update()
                else:
                    if self.args.npb: pt.update()
                    pass
                if self.args.npb: pt.finish()
                self.snapped = True
#                print("X Insert/Update lastrun.db %s:%s" % (self.args.tag, self.args.timestamp))
#                conn = sqlite3.connect(self.args.db+'mkbackup-btrfs.db')
#                #conn.execute("""insert into lastrun values (self.args.tag, self.args.timestamp)""")
#                conn.commit()
#                conn.close()

                self.scanfs() #rescan filesystem after creating the new snapshots
                ex = re.compile(self.SnapLock+'$')
                for i in self.grep_volume(ex,names=False,rev=True):
                    self.DEBUG('SnapID,SnapName %s %s'%(self.svols[i]['id'],self.svols[i]['path']),level=5)
                    self.SnapID = self.svols[i]['id']
                    listing.CreatedSubvolumes.push((self.store,self.SnapName))
                    return(list([self.svols[i]['id'],self.svols[i]['path']]))
                
                raise CreateError('FAILURE - create new snapshot failed %s' % (self.SnapLock), 0)
            except:
                raise CreateError
            #return(self.SnapLock)
        else:
            if self.args.npb: pt.finish()
            self.DEBUG('[EE] creation not possible: original not existing: %s' % (self.SourceName),level=0)
            raise CreateError('ERROR no snapshot - original not existing: %s' % (self.SourceName))
        if self.args.npb: pt.finish()


    def transfer(self):
        if self.config.getTransfer(self.tag) or self.args.action == 'transfer':
            if self.args.action == 'create':
                sname = self.SnapLock
                sid = self.SnapID
            else:
                sname = self.OrigLock
                sid = self.id

            
            #get uuids of SNP/SRC and BKP and compare. If they are the same, no transfer, if they are different, make transfer to external media
            #print(self.config.getDevice(store='BKP'))
            uuidS = self.config.getUUID(store=self.store)
            uuidB = self.config.getUUID(store='BKP')
            if None == uuidS:
                self.DEBUG(" |no-transfer: Filesystem for »%s« not mounted: »%s«" % (self.store,self.config.getDevice(store=self.store,tag=args.tag)))
                return
            if None == uuidB:
                self.DEBUG(" |no-transfer: Filesystem for »%s« not mounted: »%s«" % ('BKP',self.config.getMountPath(store='BKP',tag=args.tag)))
                return


            if uuidS == uuidB: 
                # Same Filesystem on SRC/SNP and BKP. No transfer
                self.DEBUG(' |no-transfer: external backupmedia obviously not mounted')
                return
            else:
                # Test if path to external backup-store is a btrfs-subvolume. if not, no transfer
                # first check if BKP-mount is btrfs, then check if BKP-Store exists and is a subvolume.
                # If BKP-mount is btrfs, and BKPStore does not exist, create it as subvolume
                # If BKPStore exists and is a directory, change it to subvolume
                if isbtrfs(self.config.getMountPath(store='BKP',tag=args.tag)):
                    if os.path.exists(self.BkpPath):
                        if issubvol(self.args,self.BkpPath,'BKP'):
                            self.DEBUG("BKP-Path %s is subvolume" % (self.BkpPath),level=4)
                        else:
                            self.DEBUG(" |no-transfer: %s should be subvolume, is directory on external media" % (self.BkpPath))
                            return
#                           # TODO move ro-subvolumes to another place... this code is not working
#                            try:
#                                print("%s exists; is directory" % (self.BkpPath))
#                                print("%s -> change to subvolume, this may take a while" % (self.BkpPath))
#                                # rename original BKPStore 
#                                print('A ren')
#                                cmd = ['mv',self.BkpPath,self.BkpPath+'.orig']
#                                sp_call(self.args,cmd)
#                                # Create a new Subvolume
#                                print('B cr')
#                                cmd = ['btrfs','subvolume','create',self.BkpPath]
#                                sp_call(self.args,cmd)
#                                # move content to new snapshot
#                                print('C mv')
#                                cmd = ['mv',self.BkpPath+'.orig/*',self.BkpPath]
#                                sp_call(self.args,cmd)
#                                # delete old directory
#                                print('D rm')
#                                cmd = ['rm','-rf',self.BkpPath+'.orig']
#                                sp_call(self.args,cmd)
#                                print('E')
#                            except:
#                                return

                    else:
                        print('%s not exists -> create subvolume' % (self.BkpPath))
                        self.DEBUG('isdir ==> delete ==> transfer',self.BkpPath,level=3)
                        cmd = ['btrfs','subvolume','create',self.BkpPath]
                        sp_call(self.args,cmd)
                else:
                    self.DEBUG(' |no-transfer: no subvolume for backup on external media')
                    return


            BKP = listing(self.args,store='BKP')
            transfers = dict()
            #ctransfers = dict()
            regexpart = re.compile('\.part$|\.part/')

            if self.args.action == 'transfer':
                self.scanfs() #update btrfs-list in memory

            clones = dict() #clone list
            if not self.args.no_clones:
                for par in self.grep_volume(re.compile('^'+self.OrigName.split('.')[0]+'\.'),names=False):
                    for bsub in sorted(BKP.svols):
                        if BKP.svols[bsub]['path'] == self.svols[par]['path'] and not regexpart.search(self.svols[par]['path']):
                            subbasename = re.sub('^'+self.svols[par]['path'].split('/')[0],self.basename,self.svols[par]['path'])
                            if not subbasename in clones:
                                clones[subbasename] = list()
                            clones[subbasename].append(self.svols[par]['path'])
                            self.DEBUG("Add to clones",self.svols[par]['path'],"->",subbasename,level=4)

            for sub in self.list_subvolumes(sid,names=False):
                plist = dict() #parent list
                for sis in self.list_sisters(self.svols[sub]['id'],older=True,younger=False,names=False):
                    for bsub in sorted(BKP.svols):
                        if BKP.svols[bsub]['ruuid'] == self.svols[sis]['uuid']:
                            plist[self.svols[sis]['id']] = self.svols[sis]['gen']

                
                transfers[self.svols[sub]['path']] = dict()
                if len(plist) > 0:
                    v=list(plist.values())
                    k=list(plist.keys())
                    parent = k[v.index(max(v))]
                    transfers[self.svols[sub]['path']]['parent'] = self.svols[parent]['path']
                else:
                    pass

                if len(clones) > 0:
                    bsubvol = re.sub('^'+self.svols[sub]['path'].split('/')[0],
                            self.basename,
                            self.svols[sub]['path'])
                    if bsubvol in clones:
                        transfers[self.svols[sub]['path']]['clone'] = clones[bsubvol]

            self.DEBUG(' ==transfer=> »<%s>/%s«' % (self.store,sname),level=1)
            if self.args.npb: pt = progress_timer(description= ' ==transfer=> »<%s>/%s«: ' % (self.store,sname), n_iter=len(transfers.keys())*2)
            for t in sorted(transfers.keys()):
                dest = args.config.getStorePath('BKP',args.tag)+'/'+t
                destdir = os.path.dirname(dest.rstrip('/'))+'/'
                if issubvol(self.args,dest,self.store) == False:
                    if os.path.exists(dest):
                        self.DEBUG('isdir ==> delete ==> transfer',dest,level=3)
                        cmd = ['rm','-r','-f',dest]
                        sp_call(self.args,cmd)
                    else:
                        pass
                        self.DEBUG('notexist ==> transfer', dest,level=3)
                else:
                    self.DEBUG('ignored: subvolume »%s« exists in »%s«' % (t,destdir),level=2)
                    continue

                try:
                    self.send_receive(
                            t,
                            destdir,
                            parent=transfers[t]['parent'] if 'parent' in transfers[t] else None,
                            clone=transfers[t]['clone'] if 'clone' in transfers[t] else None)
                    self.transferred = True
                except TransferError:
                    raise TransferError

                if self.args.npb: pt.update()
                try:
                    cmd = ['btrfs','property','set','-ts',dest,'ro','false']
                    sp_call(self.args,cmd,level=2)
                except:
                    raise TransferError
#            if self.transferred:
#                print("Y Insert/Update lasttrans.db %s:%s" % (self.args.tag, self.args.timestamp))

            listing.TransferedSubvolumes.push(re.sub('\.part$','',sname))
            for t in reversed(sorted(transfers.keys())):
                dest = args.config.getStorePath('BKP',args.tag)+'/'+t
                destdir = os.path.dirname(dest.rstrip('/'))+'/'
                self.DEBUG("  =set-ro>  %s" % (dest),level=1)
                try:
                    cmd = ['btrfs','property','set','-ts',dest,'ro','true']
                    sp_call(self.args,cmd,level=2)
                    if self.args.npb: pt.update()
                except:
                    raise TransferError
            if self.args.npb: pt.finish()
            return(sname)

    def send_receive(self,source,dest,parent=None,clone=None):
        tclones, tparent = list(), list()
        if parent == None:
            if clone == None:
                self.DEBUG('%-20s»<%s>/%s«' % ('  =initial transfer=>',self.store,source),level=1)
                #first = ['btrfs','send',self.StorePath+'/'+source]
            else:
                for x in sorted(clone):
                    tclones.append('-c')
                    tclones.append(self.StorePath + '/' + x)
                self.DEBUG('%-20s»<%s>/%s« <-clone: %s' % ('  =incr-clone transfer=> ',self.store,source,' '.join(tclones)),level=1)
                #first = ['btrfs','send'] + tclones + [self.StorePath+'/'+source]
        else:
            if clone != None:
                self.DEBUG('%-20s»<%s>/%s« <-parent: %s + clones' % ('  =incr transfer=> ',self.store,source,parent),level=1)
                for x in sorted(clone):
                    tclones.append('-c')
                    tclones.append(self.StorePath + '/' + x)
            else:
                self.DEBUG('%-20s»<%s>/%s« <-parent: %s' % ('  =incr transfer=> ',self.store,source,parent),level=1)
            tparent = ['-p',self.StorePath+'/'+parent]

            #first = ['btrfs','send','-p',self.StorePath+'/'+parent,self.StorePath+'/'+source]
        first = ['btrfs','send'] + tclones + tparent + [self.StorePath+'/'+source]
        second = ['btrfs','receive',dest]
        if not self.args.transferinfo:
            try:
                self.DEBUG(' '.join(first)+' | '+' '.join(second),level=3)
                process_send = subprocess.Popen(first, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
                                                shell=False)
                process_recv = subprocess.Popen(second, stdin=process_send.stdout, stderr=subprocess.DEVNULL,
                                              stdout=subprocess.PIPE, shell=False)
                # Allow process_curl to receive a SIGPIPE if process_send exits.
                process_send.stdout.close()
                out, err = process_recv.communicate()
                #self.DEBUG("out --- err",out," --- ",err,level=3)
            except:
                raise TransferError('ERROR - sending to external backup-media failed')
                pass
            return(out.decode('utf8').split('\n'))
        else:
            self.DEBUG('no transfer - only information')
            return

    def symlink_force(self,target, link_name):
        try:
            os.symlink(target, link_name)
        except OSError as e:
            if e.errno == errno.EEXIST:
                    os.remove(link_name)
                    os.symlink(target, link_name)
                    self.DEBUG("TARGET | LINKNAME:",target,'|',link_name,level=3)
            else:
                raise e
    

    def symlink(self):

        for st in list(self.args.sourcepath.keys())[0], list(self.args.destpath.keys())[0]:
            #print('C',st,self.snapped,'T',self.transferred,args.action)
# Experimenteller Code für eine externe sqlite-DB. Funktioniert noch nicht zufriedenstellend!
#            if args.action == 'create':
#                #conn = sqlite3.connect(self.args.db+'/mkbackup-btrfs.db')
#                if  (st == 'SRC' or st == 'SNP' ) and self.snapped:
#                    try:
#                        #print("A Insert SYMLINK create lasttrans.db %s:%s - %s" % (self.args.tag,self.vol, self.args.timestamp))
#                        self.args.conn.execute("INSERT INTO JOURNAL (VOL, INTNAME, SNAPNAME, SNAP_TS, TRNS_TS, DELETED) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')"% (self.vol,self.args.tag,self.SnapName,self.args.timestamp,'',0)) ;
#                    except:
#                        #print("A Update SYMLINK create lasttrans.db %s:%s - %s" % (self.args.tag,self.vol, self.args.timestamp))
#                 #       self.args.conn.execute("UPDATE LASTRUN set LRUN = '%s', DELETED = 0 where VOL='%s' AND INTV='%s'"% (self.args.timestamp,self.vol,self.args.tag)) ;
#                        self.args.conn.execute("UPDATE JOURNAL set VOL = '%s', INTNAME = '%s', SNAPNAME = '%s', SNAP_TS = '%s', TRNS_TS = '%s', DELETED = 0)"% (self.vol,self.args.tag,self.SnapName,self.args.timestamp,'')) ;
#                    pass
#                    #print('Symlink %s %s %s' % (st,self.snapped,self.transferred))
#                elif  st == 'BKP' and self.transferred:
#                    #print("B Insert/Update SYMLINK transferred lasttrans.db %s:%s" % (self.vol+'|'+self.args.tag, self.args.timestamp))
#                    try:
#                        self.args.conn.execute("UPDATE LASTRUN set LTRANS = '%s', DELETED = 0 where VOL='%s' AND INTV='%s'"% (args.timestamp,self.vol,args.tag)) ;
#                    except:
#                        self.args.conn.execute("INSERT INTO LASTRUN (VOL, INTV, LTRANS, DELETED) VALUES ('%s', '%s', '%s', 0)"% (self.vol,args.tag,args.timestamp)) ;
#                    pass
#                    #print('SymlinK %s %s %s' % (st,self.snapped,self.transferred))
#                else:
#                    return
#                self.args.conn.commit()
#                #conn.close()
#            elif args.action == 'transfer':
#                pass
#                #print("C Insert/Update SYMLINK transfer lasttrans.db %s:%s" % (self.args.tag, self.args.timestamp))
#                try:
#                    self.args.conn.execute("UPDATE LASTRUN set LTRANS = '%s', DELETED = 0 where VOL='%s' AND INTV='%s'"% (args.timestamp,self.vol,args.tag)) ;
#                except:
#                    self.args.conn.execute("INSERT INTO LASTRUN (VOL, INTV, LTRANS, DELETED) VALUES ('%s', '%s', '%s', 0)"% (self.vol+'|'+args.tag,args.timestamp)) ;
#                self.args.conn.commit()
#            elif args.action == 'delete':
#                self.DEBUG('Test if symlink points to the youngest for tag, if not - resymlink',level=1)
#                pass
#            else:
#                return
            StorePath = self.config.getStorePath(st,self.args.tag)
            if not issubvol(self.args,StorePath,self.store): continue
            linkName = self.basename+'.'+args.config.getSymLink(args.tag)
            self.DEBUG('%-12s»<%s>/%s«' % (' =symlink>',st,linkName),level=0)
            self.symlink_force('./'+self.SnapName, StorePath+'/'+linkName)
            if args.config.getSymLink(args.tag) != args.config.getSymLink(): 
                self.DEBUG('%-12s»<%s>/%s«' % (' =symlink>',st,self.basename+'.LAST'),level=0)
                self.symlink_force('./'+self.SnapName, StorePath+'/'+self.basename+'.LAST')

    def delete(self):
        self.DEBUG('%-20s from »<%s>/%s«' % (' =delete-snapshot=>',self.store, self.SourceName),level=1)
        if self.args.action == 'somethingelse':
            sname = self.SnapLock
            slock = self.SLockFile
            sid = self.SnapID
        else:
            sname = self.OrigLock
            slock = self.OLockFile
            sid = self.id
            

        #print('delete %s - %s with %s and action %s' % (sname,sid,slock,self.args.action))

        for i in self.config.getVolumes():
            #print(i,sname,i+'.part')
            if ( sname == i or sname == i+'.part' ):
                raise RuntimeError('ERROR - Systemvolume not allowed to delete: %s' % (sname),1)
                return

        if self.args.npb: pt = progress_timer(description= ' =delete-snapshot=> from »<%s>/%s«: ' % (self.store, self.SourceName), n_iter=len(self.list_subvolumes(self.id,names=True)))
        delsubs = []
        #print('<%s> is %s: ' % (self.store, self.config.getStorePath(self.store)))
        if issubvol(self.args,self.StorePath+'/'+sname,self.store):
            for sub in self.list_subvolumes(sid,names=True,rev=True,incl_self=True):
                issub = issubvol(self.args,self.StorePath+'/'+sname+'/'+sub,self.store)
                if issub == None:
                    self.DEBUG('del - not existing: '+self.StorePath+'/'+sname+'/'+sub,level=3)
                    pass
                else:
                    if issub:
                        if not os.path.isfile(self.StorePath+'/'+slock):
                            self.DEBUG(' -prepare-to-delete> <%s>/%s' % (self.store,sname+'/'+sub),level=1)
                            delsubs.append(self.StorePath+'/'+sname+'/'+sub)
                        else:
                            self.DEBUG('del - subvolume is locked: '+self.dir+'/'+sname+'/'+sub,level=3)
                        pass
                    else:
                        self.DEBUG('del - dir: '+self.dir+'/'+sname+'/'+sub,level=3)
                        pass

            if self.args.action == 'create' or self.args.action == 'cleanup':
                self.setprop(ro=False)
            if len(delsubs) > 0:
                cmd = ['btrfs','subvolume','delete','-c']
                cmd.extend(delsubs)
                self.DEBUG(' -delete-subvolumes>',level=1)
                try:
                    sp_call(self.args,cmd)
                    self.DEBUG(' -subvolumes-deleted>',level=1)
                    #linkName = self.basename+'.'+args.config.getSymLink(args.tag)
                    listing.DeletedSubvolumes.push((self.store,re.sub('\.part$','',sname)))
                    self.del_vol    = self.OrigName.split('.')[0]
                    self.del_ts     = self.OrigName.split('.')[1]
                    self.del_tag    = self.OrigName.split('.')[2]
                    #print("DELETE LASTRUN %s - %s - %s" % (self.del_vol,self.del_ts,self.del_tag))
# Experimenteller Code für eine externe Datenbank - funktioniert noch nicht
#                    try:
#                        self.args.conn.execute("UPDATE LASTRUN set DELETED = 1 where VOL='%s' AND INTV='%s' AND LRUN = '%s' "% (self.del_vol,self.args.tag,self.del_ts)) ;
#                    except:
#                        self.args.conn.execute("INSERT INTO LASTRUN (VOL, INTV, LRUN, DELETED) VALUES ('%s', '%s', '%s', 1)"% (self.del_vol,self.args.tag,self.args.timestamp)) ;
                except:
                    raise DeleteError

            else:
                print('del - no subvolumes registered')
        if self.args.npb: pt.update()

        if self.args.npb: pt.finish()
            
                
    def main(self):
            #print(self.svols)   
            #print(self.list_sisters(self.ID))
        #try:
            self.parse_btrfs_show()
    #        self.read_subvolumes(self.storename+'/'+self.name)
        #except:
        #    print("Snapshot does not exist: <%s>/%s" % (self.store,self.name))
        #    return(self.exist)

def main(args):
    for st in args.store:
        print('S',args.config.getStorePath(st,args.tag))
        for s in args.snapshots:
            print(st,s)

            L=SubVolume(args,s,store=st)
            L.list_sisters(L.id,rev=True)
            #L.main()
            #L.list_sisters()
            #X=SubVolume(listing)
            


def cleanup(args):
    DEBUG(' --== cleanup ==-->',verbose=args.verbose,level=1)
    if args.npb: pt = progress_timer(description= ' --== cleanup ==-->', n_iter=6)
    args.action = 'cleanup'
    #DEL = dict() 
    DEL = Stack()
    ST = dict()
    explock = re.compile('.*.~lock$')
    exppart = re.compile('.part$')
    partlock = dict()
    cI,I = dict(), dict()
    for i in args.config.ListIntervals():
        cI[i] = 0
        I[i]  = args.config.getInterval(i)
    #for st in args.store:
    for st in ['SRC','SNP','BKP']:
        StorePath = args.config.getStorePath(st,args.tag)
        if not issubvol(args,StorePath,st):
            DEBUG(args,' =cleanup: store doesnt exist: %s' % (StorePath),level=3)
            continue
            if args.npb: pt.update()
            if args.npb: pt.update()
        else:
            DEBUG(args,' -Cleanup store <%s>:%s' % (st,StorePath),level=3)
            StorePath = args.config.getStorePath(st,args.tag)+'/'
            ST[st] = listing(args,store=st,single=True)
            if len(args.snapshots) > 0:
                DEBUG(args,'  --cleanup interval-snapshots',level=3)
                for sn in args.snapshots:
                    ex = re.compile('$|'.join([sn+'\..*\.' + word_in_list for word_in_list in I.keys()])+'$')
                    DEBUG(args,'Regex:',ex,level=5)
                    for i in args.config.ListIntervals():
                        cI[i] = 0
                    try:
                        for i in ST[st].grep_subvolumes(ex,names=False,rev=True):
                            for tag in I.keys():
                                if ST[st].svols[i]['path'].partition('.'+tag)[1] != '':
                                    cI[tag] += 1
                                    if cI[tag] > int(I[tag]):
                                        DEL.push([st,ST[st].svols[i]['path']])
                    except:
                        raise CleanupError('cleanup failed for %s' % (sn))

            # Find unused lockfiles and delte them also
            DEBUG(args,'  --cleanup *.part$-Snapshots',level=3)
            for i in ST[st].svols:
                subvol = ST[st].svols[i]['path']
                if exppart.search(subvol): 
                    DEL.push([st,subvol])

            # Delete them
            while not DEL.is_empty():
                S = DEL.pop()
                try:
                    L=SubVolume(args,S[1],store=S[0])
                    L.lock()
                    L.delete()
                except NoSubvolumeError:
                    continue
                except:
                    raise
            if args.npb: pt.update()

            DEBUG(args,'  --cleanup unused lockfiles',level=3)
            for lf in os.listdir(args.config.getStorePath(st,args.tag)):
                if explock.search(lf):
                    if check_lockfile(args,lf):
                        pass
                    elif check_lockfile(args,lf) == None:
                        pass
                    else:
                        DEBUG(' --> remove unused lockfile: '+lf,level=1,verbose=args.verbose)
                        os.remove(lf)
            if args.npb: pt.update()

    if args.npb: pt.finish()
    return

def issubvol(args,path,store='SRC',tag=None):
    login = [] if args.config.getSSHLogin(store,tag) is None else args.config.getSSHLogin(store,tag).split(' ')
    #print("issubvol-store",store,login)
    if not path == None:
        if len(login) > 0:
            #print("Remote-Filesystem - Error issubvol")
            cmd = login + ['stat','-c%i',path]
            try:
                res = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=args.stderr)
                output,error = res.communicate()
                #print(path,res.returncode,output)
                if res.returncode > 0:
                    #print('scanfs error',self.StorePath,output,error,res.returncode)
                    #raise ScanFsError(self.StorePath)
                    output = b'0'
                    pass 
            except subprocess.CalledProcessError as e:
                #raise ScanFsError(self.StorePath)
                raise
            except:
                raise
            return True if int(output.decode()) == 256 else False
        else:
            return True if os.path.isdir(path) and os.stat(path).st_ino == 256 else False

def isbtrfs(path):
    if not path == None:
        #print(len(path.split(':')))
        if len(path.split(':')) > 1:
            print("«%s» is remote filesystem. Not checking" % (path))
            return False
        else:
            for p in psutil.disk_partitions():
                if (p.mountpoint == path and p.device != 'systemd-1') and p.fstype == 'btrfs':
                    #print(p)
                    return True
            else:
                return False
                
def create(args):
    SRC=dict()
    for snap in args.snapshots:
        try:
            SRC[snap] = SubVolume(args,snap,store=list(args.sourcepath.keys())[0])
            SRC[snap].create()
            SRC[snap].lock()
            SRC[snap].setprop(ro=True)
            SRC[snap].transfer()
            SRC[snap].symlink()
            SRC[snap].unlock()
        except RuntimeError as e:
            if e.args[1] == 0: 
                print('nicht so schlimm')
            else:
                raise e
        except (NoSubvolumeError, NoBtrfsVolumeError):
            print("Create Error: %s not found -> continue" % (snap))
            pass
        except:
            raise
    cleanup(args)
    return

def delete(args):
    for st in args.sourcepath.keys():
        SRC=dict()
        for snap in args.snapshots:
            try:
                SRC[snap] = SubVolume(args,snap,store=st)
                SRC[snap].lock()
                SRC[snap].setprop(ro=False)
                SRC[snap].delete()
            except RuntimeError as e:
                if e.args[1] == 0: 
                    print("delete error - nicht so schlimm")
                else:
                    raise e
            except (NoSubvolumeError, NoBtrfsVolumeError):
                print("Delete Error: <%s> %s not found -> continue" % (st,snap))
                pass
            except:
                raise
    return
            
def setprop(args):
    for st in args.sourcepath.keys():
        SRC=dict()
        for snap in args.snapshots:
            try:
                SRC[snap] = SubVolume(args,snap,store=st)
                SRC[snap].lock()
                SRC[snap].setprop(ro=args.ro)
                SRC[snap].unlock()
            except RuntimeError as e:
                print(e.args,e.args[1])
                if e.args[1] == 0: 
                    print("setprop error - nicht so schlimm")
                else:
                    raise e
            except (NoSubvolumeError, NoBtrfsVolumeError):
                print("Setprop Error: <%s> %s not found -> continue" % (st,snap))
                pass
            except:
                raise
    return
            
def lists(args):
    if args.info:
        if args.showpathstore:
            for st in args.store: print(args.config.getStorePath(st,args.tag))
        if args.showtags:
            for i in args.config.ListIntervals(): print(i)
        if args.showtransfers:
            if args.config.getTransfer(intv=args.tag):
                DEBUG('"%s" results in "%s", will transfer actual snapshots from this volume(s):' % (args.tag,args.config.getIsDefault(intv=args.tag)),level=1,verbose=args.verbose)
                print(' '.join(args.config.getVolumes(tag=args.tag)))
            else:
                DEBUG('%s will transfer nothing' % (args.tag),level=1,verbose=args.verbose)
        if args.showdb:
            cursor = args.conn.execute("SELECT ID, INTNAME, VOL, SNAPNAME, SNAP_TS, TRNS_TS, DELETED  from JOURNAL")
            print("Journal")
            tabstr = "%-4s%-12s %-22s  %50s | %-19s - %19s\t%s"
            print( tabstr % ("ID","Interval","Volume", "SNAMPNAME","Last run","Last Trans","Deleted"))
            for row in cursor:
                print(tabstr % (str(row[0])+':',row[1],row[2],'»'+row[3]+'«',row[4],row[5],row[6]))

        if args.print_config:
            args.config.PrintConfig(tag = None if args.tagset else args.tag, of=args.of)
            
        if args.showyoungest:
            ST=dict()
            for st in args.store:
                ST[st]=dict()
                #for vol in args.config.getVolumes():
                #print("S",args.snapshots)
                for vol in args.snapshots if len(args.snapshots) > 0 else '*':
                    #print('VOL',vol)
                    ST[st][vol]=dict()
                    for intv in args.config.ListIntervals():
                        ST[st][vol][intv] = dict()
                    if args.config.getStorePath(st,args.tag) is not None:
                        dirlist = dict()
                        for snps in glob.glob(args.config.getStorePath(st,args.tag)+'/'+vol+'.*'):
                            #print("snps",snps)
                            if len(os.path.basename(snps).split('.')) == 3: 
                                if not os.path.basename(snps).split('.')[1] in dirlist:
                                    dirlist[os.path.basename(snps).split('.')[1]] = list()
                                dirlist[os.path.basename(snps).split('.')[1]].append(os.path.basename(snps))
                        for t in sorted(dirlist.keys()):
                            for snp in dirlist[t]:
                                #print("T",dirlist[t],snp)
                                for intv in ST[st][vol].keys():
                                    R = re.compile(intv +'$') 
                                    #print("I",intv)
                                    if R.search(snp):
                                        #print("snp",st,vol,intv,snp)
                                        #ST[st][vol][intv].append(os.path.basename(snp))
                                        #print(intv,snp,os.path.basename(snps).split('.')[1])
                                        if not os.path.basename(snp).split('.')[1] in ST[st][vol][intv]:
                                            ST[st][vol][intv][os.path.basename(snp).split('.')[1]] = list()
                                        ST[st][vol][intv][os.path.basename(snp).split('.')[1]].append(os.path.basename(snp))
                        ST[st][vol]['dirlist'] = dirlist
                    #for x in ST[st][vol].keys(): print(x,ST[st][vol][x])
            for st in ST.keys():
                fp = ''
                if args.shortpath == True: fp='/'
                if args.mountpath == True: fp=args.config.getStoreName(st,args.tag)+'/'
                if args.fullpath  == True: fp=args.config.getStorePath(st,args.tag)+'/'
                DEBUG('..--==°°==--..',level=1,verbose=args.verbose)
                DEBUG('Youngest snapshot in %s' % (st),level=1,verbose=args.verbose)
                #print("ST",ST[st])
                for vol in ST[st].keys():
                    s = dict()
                    missing = list()
                    DEBUG('  Volume %s:' % (vol),level=1,verbose=args.verbose)
                    for intv in sorted(ST[st][vol].keys()):
                        #print(ST[st][vol][intv])
                        if intv != 'dirlist':
                            if len(ST[st][vol][intv]) > 0:
                                #for x in sorted(ST[st][vol][intv].keys()): print("Key",x,ST[st][vol][intv],ST[st][vol][intv][x])
                                #i = ST[st][vol][intv].pop()
                                #print("X",ST[st][vol][intv][max(ST[st][vol][intv].keys())])
                                k = max(ST[st][vol][intv].keys())
                                i = ST[st][vol][intv][k]
                                #print("i",intv,i,k)
                                if args.tagset:
                                    if args.all:
                                        #print("A")
                                        s[i.split('.')[1]] = i
                                    else:
                                        #print("B")
                                        s['dirlist'] = ST[st][vol]['dirlist'][sorted(dirlist.keys()).pop()]
                                else:
                                    #print("C",i)
                                    #if i.split('.')[2] == args.tag: 
                                        #print("D",i)
                                        #s[i.split('.')[1]] = i
                                    if intv == args.tag:
                                        s[k] = i
                            else:
                                missing.append(intv)
                        
                    lo = 0
                    for i in reversed(sorted(s.keys())):
                        #for j in s[i] if i == 'dirlist' else [s[i]]:
                        for j in s[i]:
                            #out = '»<%s>/  %s%s«' % (st,fp,j)
                            out = '%s%s«' % (fp,j)
                            lo = len(out) if len(out) > lo else lo
                            if args.verbose == 0:
                                DEBUG('%s' % (out),level=0,verbose=args.verbose)
                            else:
                                DEBUG('    %s' % (out),level=1,verbose=args.verbose)
                    DEBUG('    %s' % ('-' * (lo)),level=1,verbose=args.verbose)
                    lo = 0
                    out = """missing: %s""" % (', '.join(missing))

                    if args.tag == 'misc': DEBUG("""      %s\n      %s\n""" % (out,'=' * len(out)),level=1,verbose=args.verbose)

        if not (args.showyoungest or args.showtransfers or args.showdb or args.showtags or args.showpathstore or args.print_config):
            reintv = re.compile('NEXT|'+'|'.join(args.config.ListIntervals()))
            cmd=['systemctl','list-timers']
            try:
                #output,error = sp_co(self.args,cmd)
                res = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=args.stderr)
                output,error = res.communicate()
                if res.returncode > 0:
                    raise 
            except:
                raise
            #if output[0] == 0:
            cut =  120
            for line in output.splitlines():
                l = line.decode()
                if "ACTIVATES" in l: 
                    cut = l.find("ACTIVATES")
                    i = l.find("UNIT")
                    print(l[:cut])
                elif reintv.search(l): 
                    l = l[:cut]
                    o = l.replace("timer-","").replace(".timer","").rstrip()
                    x = o[i:].rstrip(),
                    print(o+" backup","\t--> transfer" if args.config.getTransfer(x[0]) else "")
            print("--finish--")

    else:
        text = "subvolumes in"
        if args.snap:
            text = "snapshots from"
        elif args.sisters or args.older or args.younger:
            text = "sisters from"
            if args.older:
                text = 'older '+text
            elif args.younger:
                text = 'younger '+text
            else:
                text = 'all '+text
        elif args.tree:
            text = "treeview from"
        elif args.parents:
            text = "parent from"

        for st in args.sourcepath.keys():
            SRC=dict()
            if len(args.snapshots) > 0:
                for snap in args.snapshots:
                    try:
                        SRC[snap]=SubVolume(args,snap,store=st,single=True if args.tree else False)
                        DEBUG("[II]  <%s> is %s" %(st,args.config.getStorePath()),level=1,verbose=args.verbose)
                        DEBUG("[II]  list %s <%s>/%s" %(text,st,SRC[snap].SourceName),level=1,verbose=args.verbose)
                        fp=''
                        if args.sisters or args.older or args.younger or args.parents or args.snap:
                            if args.shortpath == True: fp='/'
                            if args.mountpath == True: fp=SRC[snap].StoreName+'/'
                            if args.fullpath  == True: fp=SRC[snap].StorePath+'/'
                        else:
                            if args.shortpath == True: fp='/'+SRC[snap].SourceName+'/'
                            if args.mountpath == True: fp=SRC[snap].StoreName+'/'+SRC[snap].SourceName+'/'
                            if args.fullpath  == True: fp=SRC[snap].StorePath+'/'+SRC[snap].SourceName+'/'

                        if args.snap:
                            # List children of snapshot
                            #for i in SRC[snap].list_snapshots(SRC[snap].uuid,rev=args.reverse): print(fp+SRC[snap].SourceName+i)
                            for i in SRC[snap].list_snapshots(SRC[snap].uuid,rev=args.reverse): print(fp+i)
                        elif args.sisters or args.older or args.younger:
                            # List sisters of snapshot (same parent)
                            for i in SRC[snap].list_sisters(SRC[snap].id,rev=args.reverse): print(fp+i)
                        elif args.tree:
                            #print("Treeview of snapshots under %s - in development" % (snap))
                            SRC[snap].build_tree(snap=snap,st=st)
                        elif args.parents:
                            #print("Parentview of snapshots - in development")
                            for i in SRC[snap].list_parent(SRC[snap].puuid): print(fp+i)
                        else:
                            #DEBUG("List subvolumes in given snapshot %s" % (snap),level=1,verbose=args.verbose)
                            for i in SRC[snap].list_subvolumes(SRC[snap].id,rev=args.reverse): print(fp+i)
                    except RuntimeError as e:
                        print(e.args,e.args[1])
                        if e.args[1] == 0: 
                            print("list error - nicht so schlimm")
                        else:
                            raise e
                    except (NoSubvolumeError, NoBtrfsVolumeError):
                        print("List Error: <%s>/%s not found -> continue" % (st,snap))
                        pass
                    except ScanFsError:
                        pass
                    except:
                        raise
            else:
                #if args.tree:
                    print("Treeview of snapshots in %s - in development" % (st))
                    SRC['.']=SubVolume(args,'.',store=st,single=True if args.tree else False)
                    SRC['.'].build_tree(snap='.',st=st)

    return

def transfer(args):
    SRC=dict()
    for snap in args.snapshots:
        try:
            SRC[snap] = SubVolume(args,snap,store=list(args.sourcepath.keys())[0])
            SRC[snap].lock()
            SRC[snap].transfer()
            SRC[snap].unlock(store=list(args.sourcepath.keys())[0])
        except (NoSubvolumeError, NoBtrfsVolumeError):
            #print("Transfer Error: <%s> %s not found -> continue" % (st,snap))
            print("Transfer Error: %s not found -> continue" % (snap))
            pass
        except:
            raise
    cleanup(args)

def restore(args):
    #print('RESTORE FILES', args)
    if os.getuid() == 0:
        uroot = True  
    else:
        uroot = False

    if args.no_preserve:
        cpopts=['-b','--suffix=.'+args.timestamp+'.bak']


    for f in args.file:
        #print('restore',os.getcwd(),f,os.path.realpath(f))
        src = os.path.realpath(f)
        bkpsubdir = '/'
        mountp = src
        while mountp > '/':
            cmd=['mountpoint',mountp]
            try:
                res = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=args.stderr)
                output,error = res.communicate()
                if res.returncode > 0:
                    bkpsubdir = mountp
                    mountp = os.path.dirname(mountp)
                else:
                    break
            except:
                raise
        #print(mountp,bkpsubdir,src.replace(bkpsubdir,''))
        mounts = open('/proc/mounts','r')
        R = re.compile(' '+mountp+' ')
        for line in mounts.readlines():
            if R.search(line):
                FS = line.split(' ')[2]
                #print(FS,uroot)
                if FS == "fuse.MksnapshotFS.py":
                    if uroot:
                        dst = src.replace(bkpsubdir,'')
                    else:
                        dst = os.environ['HOME']+src.replace(bkpsubdir,'')
                else:
                    if mountp in [args.config.getMountPath('BKP',args.tag,original=False), args.config.getMountPath('SNP',args.tag,original=False)]:
                        dst = src.replace(bkpsubdir,'')
                        #print(dst)
                    else:
                        dst = ''
                        print('no backup - no restore')
                #print('cp', '-b', '--suffix=.'+args.timestamp+'.bak', src, dst)
                if not args.no_preserve:
                    bkp = dst+'.'+args.timestamp+'.bak~'
                    try:
                        os.rename(dst,bkp)
                    except:
                        raise

                #print('cp',src,dst)
                #print('no copy - do it manually - activate in code')
                try:
                    shutil.copytree(src, dst)
                    print("File restored from %s: %s" % (src,dst))
                except OSError as exc: # python >2.5
                    if exc.errno == errno.ENOTDIR:
                        shutil.copy(src, dst)
                        print("File restored from %s: %s" % (src,dst))
                    else: raise
                #shutil.copy(src,dest)
        mounts.close()
                        



# PARSER

config=Config()

parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version', version='0.1.0')
parser.add_argument('-V', '--systemvolumes', action='store_true',
        default=False, help='''take the systemvolumes from config. store is
        always SNP''')
parser.add_argument('-t', '--tag', default=None, help='''one of %s''' % (config.ListIntervals()))
parser.add_argument('-v', '--verbose', action='count', default=0, help='''verbose output''' )
#parser.add_argument('-i', '--info', action='store_true', default=False, help='''Print infos, action is "list"''')
parser.add_argument('-i', '--ignore', action='append', help='''Regular expression pattern for ignoring several subvolumes to be not backed up (and subvolumes unter them)
        Use it more than once''')
parser.add_argument('-n', '--no-progressbar', dest='npb', action='store_false', default=True, help='''Dont show progressbar (for use in systemctl-unit for example)''')
parser.add_argument('-B', '--backup-mount-path', 
        dest='bkpmount', 
        default=config.getMountPath('BKP'), 
        help='''set path to destination mountpoint of backup-mountpoint. (default=%s) overrides 'BKP-Path':''' % (config.getMountPath('BKP')))
parser.add_argument('-b', '--backup-store', 
        dest='bkpstore', 
        default=config.getStoreName('BKP'), 
        help='''set storename in backup-mount. (default=%s) overrides 'BKP-Store':''' % (config.getStoreName('BKP')))
parser.add_argument('-S', '--snapshot-mount-path', 
        dest='snpmount', 
        default=config.getMountPath('SNP'), 
        help='''set path to destination mountpoint of snapshot-mountpoint. (default=%s) overrides 'SNP-Path':''' % (config.getMountPath('SNP')))
parser.add_argument('-s', '--snapshot-store', 
        dest='snpstore', 
        default=config.getStoreName('SNP'), 
        help='''set storename in snapshot-mount. (default=%s) overrides 'BKP-Store':''' % (config.getStoreName('SNP')))
#parser.set_defaults(func=main)

subparsers = parser.add_subparsers()

list_parser=subparsers.add_parser('list')
list_parser.add_argument("store", 
                        default='SRC', 
                        metavar='stores and snapshots',
                        nargs='*',
                        help="""one of SRC, BKP or SNP - where is the snapshot
                        located and one ore more snapshots""")
list_parser.add_argument('-r', '--reverse', action='store_true', default=False)
#list_parser.add_argument('--snap', action='store_true', default=False, help='list snapshots from the queried snapshot')
list_parser.add_argument('-p', '--parents', action='store_true', default=False, help="list parent snapshot from the queried snapshots")
list_parser.add_argument('-S', '--sisters', action='store_true', default=False, help="list snapshots from the queried snapshot with same parent (=sisters)")
list_parser.add_argument('-O', '--older-sisters', action='store_true', dest='older', default=False, help="list snapshots from the queried snapshot with same parent (=sisters) and smaller cgen")
list_parser.add_argument('-Y', '--younger-sisters', action='store_true', dest='younger', default=False, help="list snapshots from the queried snapshot with same parent (=sisters) and bigger cgen")
list_parser.add_argument('-c', '--children', dest='snap', action='store_true', default=False, help="""list snapshots from the queried snapshot""")
list_parser.add_argument('-f', '--fullpath', action='store_true', default=False, help="print full path from /")
list_parser.add_argument('-s', '--shortpath', action='store_true', default=False, help="print path including snapshotname")
list_parser.add_argument('-m', '--mountpath', action='store_true', default=False, help="print path relative to mountpoint of btrfs")
list_parser.add_argument('-i', '--info', dest='info', action='store_true', default=False, help="""Show infos on mkbackup""")
list_parser.add_argument('-P', '--show-StorePath', dest='showpathstore', action='store_true', default=False, help="""Print path of given stores""")
list_parser.add_argument('-t', '--show-tags', dest='showtags', action='store_true', default=False, help="""Print all available tags""")
list_parser.add_argument('-T', '--show-transfers', dest='showtransfers', action='store_true', default=False, help="""Print volumes to transfer by choosen tag""")
list_parser.add_argument('-d', '--show-database', dest='showdb', action='store_true', default=False, help="""Print whole snapshot-database""")
list_parser.add_argument('-y', '--show-youngest', action='store_true', dest='showyoungest', default=False, help="list youngest snapshots in store, with '-t tag' only for this tag")
list_parser.add_argument('--print-config', action='store_true', default=False, help="show the whole configuration or only for the given tag")
list_parser.add_argument('-o', '--outfile', dest='of', default=None, help="print configuration to this file, instead of stdout. Only in combination mit --print-config")
list_parser.add_argument('--all', dest='all', action='store_true', default=False, help="""show full list of all youngest snapshots in all intervals for all volumes (only in combination with -y""")
list_parser.add_argument('--tree', dest='tree', action='store_true', default=False, help="""Build tree from all snapshots (without subvolumes in it)""")
list_parser.set_defaults(func=lists)
list_parser.set_defaults(action='list')

create_parser=subparsers.add_parser('create')
create_parser.add_argument("store", 
                        default='SRC', 
                        metavar='stores and snapshots',
                        nargs='*',
                        help="""one of SRC or SNP - where is the snapshot located and one ore more snapshots
                        which to be created in the same store.
                        BKP is ignored!!!""")
create_parser.add_argument('--no-clones', action='store_true', default=False, help="""do not use clones for transfer, only parent (if present)""")
create_parser.set_defaults(func=create)
create_parser.set_defaults(action='create')

delete_parser=subparsers.add_parser('delete')
delete_parser.add_argument("store", 
                        default='SRC', 
                        metavar='stores and snapshots',
                        nargs='*',
                        help="""one of SRC, BKP or SNP - where is the snapshot
                        located and one ore more snapshots""")
delete_parser.set_defaults(func=delete)
delete_parser.set_defaults(action='delete')

transfer_parser=subparsers.add_parser('transfer')
transfer_parser.add_argument("snapshots", 
                        default='SRC', 
                        nargs='*',
                        help="""one of SRC or SNP - where is the snapshot located and one ore more snapshots
                        which to be transfered to the external backup-device.
                        BKP is ignored!!!""")
transfer_parser.add_argument('--no-clones', action='store_true', default=False, help="""do not use clones for transfer, only parent (if present)""")
transfer_parser.add_argument('-i', '--info', 
        dest='transferinfo', 
        action='store_true', 
        default=False, 
        help="""show only if initial or incremental transfer is done and the parents""")
transfer_parser.set_defaults(func=transfer)
transfer_parser.set_defaults(action='transfer')

cleanup_parser=subparsers.add_parser('cleanup')
cleanup_parser.add_argument("snapshots", 
                        nargs='*',
                        help='''cleanup all snapshots, which are older and more
                        than allowed in config''')
cleanup_parser.set_defaults(func=cleanup)
cleanup_parser.set_defaults(action='cleanup')

setprop_parser=subparsers.add_parser('setprop')
setprop_parser.add_argument("store", 
                        default='SRC', 
                        metavar='stores and snapshots',
                        nargs='*',
                        help='''one of SRC, BKP or SNP - where is the snapshot
                        located and one ore more snapshots''')
setprop_parser.add_argument("-r", "--ro", 
                        default=False,
                        action='store_true',
                        help='''setproperty to readonly. If -r is not given,
                        property is set to read-write''')
setprop_parser.set_defaults(func=setprop)
setprop_parser.set_defaults(action='setprop')

restore_parser=subparsers.add_parser('restore')
restore_parser.add_argument("file", 
                        nargs='*',
                        help="""restore all given files""")
restore_parser.add_argument("-n", "--no-preserve", 
                        default=False,
                        action='store_true',
                        help="""if set, the original file will be overwritten. If not set,
                        the original file is renamed to filename.restore-${TIMESTAMP}""" )
restore_parser.set_defaults(func=restore)
restore_parser.set_defaults(action='restore')



if __name__ == '__main__':
    args = parser.parse_args()
    #args.config = Config()
    args.config = config
    stores = []
    snapshots = []

    if 'store' in args: 
        if isstring(args.store): args.store = args.store.split(' ')
    else:
        args.store = []

    if 'snapshots' in args: 
        if isstring(args.snapshots): args.snapshots = args.snapshots.split()
    else:
        args.snapshots = []
    for i in args.store + args.snapshots:
        if i == 'SNP' or i == 'SRC' or i == 'BKP':
            stores.extend([i])
        else:
            snapshots.extend([i.rstrip('/')])
    if len(stores) == 0: stores = ['SRC']

    args.store = stores
    args.snapshots = snapshots

    #print(args.store,args.snapshots)

    # set pathes in config to the given from cmdlin or default
    args.config.setBKPPath(args.bkpmount)
    args.config.setBKPStore(args.bkpstore)
    args.config.setSNPPath(args.snpmount)
    args.config.setSNPStore(args.snpstore)

    # tag = None is not allowed. Set it to misc, if not set
    args.tagset = False
    if args.tag == None: 
        args.tag = 'misc'
        args.tagset = True # if no tag was given, and tag is set here, this value is true - it indicates, tag was set automatically to 'misc'


    if args.systemvolumes:
        args.snapshots=args.config.getVolumes(tag=args.tag)
        if len(args.store) == 0: args.store=['SNP']

    # set store and path to store depending on action
    args.sourcepath, args.destpath  = dict(), dict()
    if args.action == 'create' or args.action == 'transfer':
        if 'BKP' in args.store: args.store.pop(args.store.index('BKP'))
        if 'SRC' in args.store or 'SNP' not in args.store:
            args.sourcepath['SRC'] = args.config.getStorePath('SRC',args.tag)
        else:
            args.sourcepath['SNP'] = args.config.getStorePath('SNP',args.tag)
        args.destpath['BKP'] = args.config.getStorePath('BKP',args.tag)
    else:
        if len(args.store) == 0:
            args.sourcepath['SRC'] = args.config.getStorePath('SRC',args.tag)
            args.destpath['BKP'] = args.config.getStorePath('BKP',args.tag)
        else:
            for st in args.store:
                args.sourcepath[st] = args.config.getStorePath(st,args.tag)
                args.destpath[st] = args.config.getStorePath(st,args.tag)

    DEBUG('SRC',args.sourcepath,level=5,verbose=args.verbose)
    DEBUG('DST',args.destpath,level=5,verbose=args.verbose)

    # Set timestamp equal for all operations
    args.ts  = datetime.datetime.now()
    args.timestamp = args.ts.strftime('%Y-%m-%d_%H:%M:%S')
    #args.timestamp    = datetime.datetime.now().strftime('%Y-%m-%d_%H:%M:%S')

    if hasattr(args, 'transferinfo'):
        args.verbose += 1
    else:
        args.transferinfo = False

    # set stdout and stderr for output of subprocess-calls for the verbose-levels
    if args.verbose <= 1:
        args.stdout=subprocess.DEVNULL
        args.stderr=subprocess.DEVNULL
    elif args.verbose <=2:
        args.stdout=subprocess.DEVNULL
        args.stderr=None
    elif args.verbose > 2:
        args.stdout=None
        args.stderr=None

    if args.verbose > 0:
        args.npb = False 
        
    args.db = '/var/lib/mkbackup-btrfs'
    if not os.path.exists(args.db) and not os.path.exists(args.db+'/mkbackup-btrfs.db'):
        create_db(db=args.db)

    args.conn = sqlite3.connect(args.db+'/mkbackup-btrfs.db')

    #DEBUG("Arguments",args,verbose=args.verbose)
    if args.verbose > 3:
        DEBUG("Arguments",verbose=args.verbose)
        for i in sorted(vars(args)):
            DEBUG(i+': '+str(getattr(args,i,None)),verbose=args.verbose)
    elif args.verbose > 1:
        DEBUG("Arguments",args,verbose=args.verbose)


    # Run action
    args.func(args)

    # Check symlinks in stores, if they exist and ok or missing.
    #for vol in Config().getVolumes():
    for vol in args.config.getVolumes():
        for st in (args.sourcepath.keys()):
            p = args.sourcepath[st]
            #for sln in Config().ListSymlinkNames():
            for sln in args.config.ListSymlinkNames():
                link = p+'/'+vol+'.'+sln
                if os.path.exists(link):
                    if os.path.islink(link):
                        DEBUG("Symlink ok: %s/%s.%s" % (st,vol,sln),level=4,verbose=args.verbose)
                    else:
                        DEBUG("Symlink broken: %s/%s.%s --> remove it" % (st,vol,sln),level=4,verbose=args.verbose)
                        os.remove(link)
                else:
                    DEBUG("Symlink missing: %s/%s.%s" % (st,vol,sln),level=4,verbose=args.verbose)
    for t in args.config.ssh_cons.keys():
        print("Close Connection to %s" % (t))
        args.config.ssh_cons[t].close()
#        for s in args.config.ssh[t].keys():
#            if not args.config.ssh[t][s]['ssh'] == None:
#                print("CLOSE",t,s)
#                args.config.ssh[t][s]['ssh'].close() 

    # print summary over all actions 
    if not args.action == 'list' and not args.action == 'restore':
        DEBUG("---=== SUMMARY ===---",level=0,verbose=args.verbose)
        DEBUG("""Stores: %s
snapshots: %s
                """ % (args.store,args.snapshots))
        DEBUG("Created Subvolumes:",level=0,verbose=args.verbose)
        while not listing.CreatedSubvolumes.is_empty():
            print(listing.CreatedSubvolumes.pop())
        print('''---
''')
        DEBUG("Transfered Subvolumes:",level=0,verbose=args.verbose)
        while not listing.TransferedSubvolumes.is_empty():
            print(listing.TransferedSubvolumes.pop())
        print('''---
''')
        DEBUG("Deleted Subvolumes:",level=0,verbose=args.verbose)
        while not listing.DeletedSubvolumes.is_empty():
            print(listing.DeletedSubvolumes.pop())
        print('---')

    DEBUG("---== (%s) finnished %s %s at %s ==---" % (os.getpid(),args.func.__name__, args.tag, args.timestamp),level=1,verbose=args.verbose)
#

#!/usr/bin/python3 -u
#!/usr/bin/pkexec /usr/bin/python3

import argparse
import re
import datetime
import subprocess
import os
import sys
import errno
import glob
import progressbar as pb
import shutil
import psutil
# sqlite3 is used for writing database about last runs - it is read by list and from gnome-extension (planned)
import sqlite3

# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
PY34 = sys.version_info[0:2] >= (3, 4)

# --- Logger ---
import logging


try:
    from anytree import Node, RenderTree
    TREE=True
except:
    TREE=False

import dbus
import dbus.service
#import dbus.glib

from dbus.mainloop.glib import DBusGMainLoop
DBusGMainLoop(set_as_default=True)

from mkbackup.system_notification_emitter import Emitter
from mkbackup.mkbackup_emitter import Emitter as EM

#from mksnapshotconfig import Config
from mkbackup.mkbackup_btrfs_config import Config, MountInfo, connect, Myos, __version__
from mkbackup.mkbackup_btrfs_config import __version__ as confversion

__author__ = "Jakobus Schürz <jakob@schuerz.at>"
__version__ = "1.01.0"

class Notification(Emitter):
    def __init__(self):
        super().__init__(conn=dbus.SystemBus(), object_path='/at/xundeenergie/notifications/advanced')

class EmDBUS(EM):
    """ Example to use
    progress = Emitter(dbus.SystemBus(),
            '/at/xundeenergie/mkbackup/Status')

    progress.start(
            {'intv': 'hourly'})

    progress.update(
            {'intv': 'hourly', 'progr': 5})

    progress.finished(
            {'intv': 'hourly'})

    progress.reset(
            {'intv': 'hourly'})
    """
    def __init__(self):
        super().__init__(conn=dbus.SystemBus(), object_path='/at/xundeenergie/mkbackup/Status')

#define progress timer class
class progress_timer:

    def __init__(self, n_iter, description="Something"):
        self.n_iter         = n_iter
        self.iter           = 0
        self.description    = description + ': '
        self.timer          = None
        self.initialize()

    def initialize(self):
        #initialize timer
        widgets = [self.description, pb.Percentage(), ' ',
                   pb.Bar(marker=pb.RotatingMarker()), ' ', pb.ETA()]
        self.timer = pb.ProgressBar(widgets=widgets, maxval=self.n_iter).start()

    def update(self, q=1):
        #update timer
        self.timer.update(self.iter)
        self.iter += q

    def finish(self):
        #end timer
        self.timer.finish()

# RuntimeError definitions:
# RuntimeError(msg, code)
# code:
# 0 - continue programm
# 1 - raise error

if hasattr(os, 'sync'):
    sync = os.sync
else:
    import ctypes
    libc = ctypes.CDLL('libc.so.6')
    def sync():
        libc.sync()

#def DEBUG(*msg, level=0, verbose=0):
#    if verbose < level :
#        return
#    else:
#        #print(' '.join(msg))
#        for i in msg: print(i)
#        return

def isstring(s):
    # if we use Python 3
    if (sys.version_info[0] == 3):
        return isinstance(s, str)
    # we use Python 2
    return isinstance(s, basestring)

def check_lockfile(args,lf):
    # Returns True, when lockfile is in use, and False if lockfile is unused
    # Returns None, when lockfile is not existing
    for st in args.store:
        if Myos().path_isfile(lf,args.config.getssh(args.tag,st)):
            file = open(lf, 'r')
            pid = file.readline()
            file.close()
            #if len(pid) > 0 and Myos().path_isfile('/proc/'+pid+'/cmdline',args.config.ssh[args.tag][st]):
            if len(pid) > 0 and os.path.isfile('/proc/'+pid+'/cmdline'):
                logger.warning('lockfile %s in use with process %s' % (lf,pid))
                #DEBUG('lockfile %s in use with process %s' % (lf,pid),level=3,verbose=args.verbose)
                return(True)
            else:
                logger.warning('lockfile %s unused' % (lf))
                #DEBUG('lockfile %s unused' % (lf),level=3,verbose=args.verbose)
                return(False)
        else:
            logger.warning('lockfile %s not existing' % (lf))
            #DEBUG('lockfile %s not existing' % (lf),level=3,verbose=args.verbose)
            return(None)

class Stack:
    def __init__(self):
        self.item = []

    def push(self,item):
        self.item.append(item)

    def pop(self):
        return self.item.pop()

    def is_empty(self):
        return(self.item == [])

    def len(self):
        return(len(self.item))

    def all(self):
        return(self.item)


class Error(Exception):
    pass

class NoSubvolumeError(Error):
    def __init__(self):
        print("ERROR - Snapshot not found" )
    pass

class ScanFsError(Error):
    def __init__(self,vol='unknown'):
        print("ERROR - scanfs. Volume not found or no Permissions: %s"  % (vol))
        pass
    pass

class NoBtrfsVolumeError(Error):
    def __init__(self,vol='unknown'):
        pass
    pass

class TransferError(Error):
    pass

class CreateError(Error):
    pass

class SetpropError(Error):
    pass

class DeleteError(Error):
    pass

class SystemVolumeError(Error):
    def __init__(self,action='undefined'):
        print("Action %s on Systemvolume not allowed" % (action))

class BtrfsListing:
    what = "BtrfsListing of all subvolumes in store"
    CreatedSubvolumes = Stack()
    DeletedSubvolumes = Stack()
    TransferedSubvolumes = Stack()



    def __init__(self,args,store='SRC',single=False):
        #BtrfsListing.Lists.push(store)
        self.args      = args
        self.store     = store
        self.single    = single
        self.verbose   = args.verbose
        self.StoreList = store # List is from which store
        self.MountPath = args.config.getMountPath(self.store,self.args.tag,original=False) # path from / to the mountpoint of store
        self.StoreName = args.config.getStoreName(self.store,self.args.tag) # path of store below the mountpoint
        self.StorePath = args.config.getStorePath(self.store,self.args.tag) # whole path from / to directory where the snapshot lives
        self.BkpPath   = args.config.getStorePath('BKP',self.args.tag) # whole path from / to directory where the snapshot lives
        self.svols     = dict()
        self.args      = args
        self.scanfs()

    def scanfs(self):
        logger.warning('SCAN btrfs-drive: %s' % (self.StorePath))
        if self.single:
            cmd=['btrfs','subvolume','list','-R','-u','-q','-c','-o',self.StorePath]
        else:
            cmd=['btrfs','subvolume','list','-R','-u','-q','-c',self.StorePath]

        output = self.args.config.remotecommand(tag=self.args.tag, store=self.store, cmd=cmd)
        try:
            for line in output.splitlines():
                # btrfs-subvolume list 4.13 output field separator is not anymore only one space. uuid-fields are filled up with whitespaces, so split(' ') does not work anymore!!!
                #argmts = line.split(' ')
                argmts = line.split()
                #ID 2412 gen 8547 cgen 8547 top level 2393 parent_uuid 7991115b-8a6b-6d4d-b664-03db01e902d0 received_uuid - uuid 368490e7-5aca-0d4d-9b7a-becff0487ebd path aldebaran/__ALWAYSCURRENT__.2016-10-15_22:40:25.hourly.part/var-spool-dovecot
                self.svols[argmts[1]] = dict()
                self.svols[argmts[1]]['id']    = argmts[1]
                self.svols[argmts[1]]['gen']   = argmts[3]
                self.svols[argmts[1]]['cgen']  = argmts[5]
                self.svols[argmts[1]]['tlid']  = argmts[8]
                self.svols[argmts[1]]['puuid'] = argmts[10]
                self.svols[argmts[1]]['ruuid'] = argmts[12]
                self.svols[argmts[1]]['uuid']  = argmts[14]
                self.svols[argmts[1]]['path']  = ' '.join(argmts[16:])
        except:
            print("Subvolume not found: %s" %(self.StorePath))

#    def DEBUG(*msg, self,level=0):
#        if self.verbose >= level :
#            for i in msg: print(i)
#        return

    def _ret(self,ret,reverse=False):
        return(reversed(ret) if reverse else ret)

    def build_tree(self,snap=None,st="/"):
        if TREE:
            wood = Node(self.config.getStorePath(st,args.tag)+' ('+st+')')
            stroot="wood"
            isbkp = self.config.getStorePath(st,args.tag) == self.config.getStorePath('BKP',args.tag)
            for sub in sorted(self.svols.keys(),key=int):
                if self.svols[sub]['path'] == snap: stroot = self.svols[sub]['uuid']
                ext = " (gen: "+str(self.svols[sub]['gen'])+" cgen: "+str(self.svols[sub]['gen'])+")"
                try:
                    vars()[str(self.svols[sub]['uuid'])] = Node(str(self.svols[sub]['path'])+ext,parent=vars()[self.svols[sub]['puuid']])
                except:
                    vars()[str(self.svols[sub]['uuid'])] = Node(str(self.svols[sub]['path'])+ext,parent=wood)

            for pre, fill, node in RenderTree(wood if snap == None else vars()[stroot]):
                print("%s%s" % (pre, node.name))
        else:
            print("""anytree is not available. Please ask your sysadmin to install anytree with
            pip3 install anytree""")

    def list_sisters(self,ID,rev=False,older=None,younger=None,names=True):
        result = []
        if older   == None: older = self.args.older
        if younger == None: younger = self.args.younger
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['puuid'] == self.svols[ID]['puuid'] and not sub == ID:
                if older:
                    if int(self.svols[sub]['gen']) >= int(self.svols[ID]['gen']): continue
                if younger:
                    if int(self.svols[sub]['gen']) <= int(self.svols[ID]['gen']): continue
                logger.debug('SISTER %s %s' % (self.svols[sub]['id'],self.svols[sub]['path']))
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def list_parent(self,puuid,rev=False,names=True):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['uuid'] == puuid:
                logger.debug('PARENT %s ' % (self.svols[sub]['path']))
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def list_snapshots(self,uuid,rev=False,names=True):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['puuid'] == uuid:
                logger.debug('PARENTX %s %s %s' % (names,sub,self.svols[sub]['path'] if names else sub,"Y"))
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def grep_volume(self,expr,names=True,rev=False):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if expr.search(self.svols[sub]['path']):
                logger.debug('REGEX %s' % (self.svols[sub]['path']))
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def grep_subvolumes(self,expr,names=True,rev=False):
        result = []
        for sub in sorted(self.svols.keys(),key=int):
            if expr.search(self.svols[sub]['path']):
                logger.debug('REGEX %s' % (self.svols[sub]['path']))
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def _lssub(self,id):
        # recursiv BtrfsListing of all subvolumes below a given snapshot
        result = []
        for i in self.svols:
            if self.svols[i]['tlid'] == id:
                result.append(self.svols[i]['id'])
                for i in self._lssub(self.svols[i]['id']):
                    result.append(i)
        return(result)

    def list_subvolumes(self,id,rev=False,names=True,incl_self=True):
        result= []
        first = '' if names else id
        if incl_self: result.append(first)
        for sub in self._lssub(id):
            result.append(self.svols[sub]['path'].partition(self.svols[id]['path']+'/')[2]) if names else result.append(sub)
        return(self._ret(result,reverse=rev))

    def count_subvolumes(self,id,incl_self=True):
        result = 0
        result = len(self._lssub(id))
        return(result if incl_self else result + 1)

    def get_oldest(self,ID,rev=False,older=None,younger=None,names=True):
        result = []
        if older   == None: older = self.args.older
        if younger == None: younger = self.args.younger
        for sub in sorted(self.svols.keys(),key=int):
            if self.svols[sub]['puuid'] == self.svols[ID]['puuid'] and not sub == ID:
                if older:
                    if self.svols[sub]['gen'] >= self.svols[ID]['gen']: continue
                if younger:
                    if self.svols[sub]['gen'] <= self.svols[ID]['gen']: continue
                logger.debug('SISTER',self.svols[sub]['id'],self.svols[sub]['path'])
                #self.DEBUG('SISTER',self.svols[sub]['id'],self.svols[sub]['path'],level=5)
                result.append(self.svols[sub]['path']) if names else result.append(sub)
        return(self._ret(result,reverse=rev))


    def _isbtrfs(self,path,store='SRC',tag='DEFAULT'):
        mi = MountInfo(conn=self.args.config.getssh(tag,store))
        logger.info("Filesysem for »%s« is %s" % (path,mi.fstype(path)))
        #self.DEBUG("Filesysem for »%s« is %s" % (path,mi.fstype(path)),level=2)
        return True if mi.fstype(path) == 'btrfs' else False

    def main(self):
        self.scanfs()

class SubVolumeInfo(BtrfsListing):

    def __init__(self,args,name,store='SRC',single=False):
        super().__init__(args,store=store,single=single)
        if store    == 'SRC':
            self.SourceName  = os.path.basename(name.rstrip('/'))
        else:
            self.SourceName  = name.strip('/')
        self.vol          = name
        self.uuid         = '' # UUID
        self.puuid        = '' # Parent-UUID
        self.ruuid        = '' # Received UUID
        self.ctime        = '' # Creation Time
        self.id           = 0  # subvolume-ID
        self.gen          = 0  # Generation
        self.cgen         = 0  # Generation at creationtime
        self.pid          = 0  # Parent ID
        self.tlid         = 0  # Top level ID
        self.flags        = 0  # Flags
        self.snapshots    = [] # List of snapshots made from this subvolume
        self.translate={'Name':'SourceName',
                        'UUID':'uuid',
                        'Parent UUID':'puuid',
                        'Received UUID':'ruuid',
                        'Creation time':'ctime',
                        'Subvolume ID':'id',
                        'Generation':'gen',
                        'Gen at creation':'cgen',
                        'Parent ID':'pid',
                        'Top level ID':'tlid',
                        'Flags':'flags',
                        'Snapshot(s)':'snapshots'}
        self.parse_btrfs_show()

    def parse_btrfs_show(self):
        logger.info('[II]  parse subvolume store<%s> %s' % (self.store,self.SourceName))
        #self.DEBUG('[II]  parse subvolume store<%s> %s' % (self.store,self.SourceName),level=2)
        subvolume_data = dict()
        if self.SourceName.startswith(self.StoreName):
            SourceName = re.sub(self.StoreName+'/','',self.SourceName)
        else:
            SourceName = self.SourceName
        cmd = ['btrfs','subvolume','show',self.StorePath+'/'+SourceName]
        sv = False
        snaps=[]
        output = self.args.config.remotecommand(tag=self.args.tag, store=self.store, cmd=cmd)

        try:
            for line in output.splitlines():
                #argmnts = [arg.strip() for arg in str(line, encoding='utf8').split(': ')]
                argmnts = [arg.strip() for arg in line.replace('\t',' ').split(': ')]

                if len(argmnts) > 1:
                    #setattr(self, self.tr_att(argmnts[0].strip()), argmnts[1].strip())
                    setattr(self, self.tr_att(argmnts[0]), argmnts[1])
                elif sv:
                    snaps.append(argmnts[0].strip())
                else:
                    if argmnts[0].strip() == 'Snapshot(s):':
                        sv = True
                    else:
                        self.path=argmnts[0].strip()
            self.snapshots = snaps
            self.dir       = os.path.dirname(self.path)
            return
        except:
            print("Subvolume does not exist: %s" % (self.SourceName))


class SubVolume(SubVolumeInfo):
    # read Subclasses:  http://www.python-course.eu/python3_inheritance.php
    what = 'store all informations about a btrfs-Subvolume'

    def __init__(self, args, name, store='SRC', single=False, mdbslice=100):
        super().__init__(args,store=store,name=name,single=single)
        self.snapped      = False
        self.transferred  = False
        self.exist        = True

        self.args         = args
        self.timestamp    = args.timestamp
        self.verbose      = args.verbose
        self.tag          = args.tag
        self.config       = args.config #Config()
        self.path         = ''
        self.dir          = ''
        self.basename     = os.path.basename(name.split('.')[0])
        if args.action == 'rollback':
            self.otimestamp   = os.path.basename(name.split('.')[1])
        if args.action == 'transfer':
            self.trans_ts     = name.split('.')[1]
            self.trans_tag    = name.split('.')[2]

        regexpart         = re.compile('\.part')

        self.OrigName     = re.sub('\.part$','',self.SourceName)
        self.OrigLock     = self.OrigName+'.part'
        if args.action == 'transfer':
            self.OLockFile = '.'+self.basename+'.'+self.trans_ts+'.'+self.trans_tag+'.~lock'
        else:
            self.OLockFile    = '.'+self.OrigName+'.~lock' if args.action != 'transfer' else '.'+self.SourceName+'.~lock'
        if args.action == 'rollback':
            print('rollback',self.OrigName,self.basename,self.otimestamp)
            self.SnapName     = self.basename+'.rollback-from-'+self.otimestamp+'-on-'+self.timestamp+'.'+"current"
            self.SysVol       = MountInfo().relpath('/')
            self.SysVolOld       = self.SysVol.split('.')[0]+'.'+self.timestamp+'.oldcurrent'
        else:
            self.SnapName     = self.basename+'.'+self.timestamp+'.'+self.tag
        self.SnapLock     = self.SnapName+'.part'
        self.SLockFile    = '.'+self.SnapName+'.~lock'
        self.SnapID       = None
        logger.warning('OrigName  : %s' % (self.OrigName))
        logger.warning('SourceName: %s' % (self.SourceName))
        logger.warning('OrigLock  : %s' % (self.OrigLock))
        logger.warning('OLockFile : %s' % (self.OLockFile))
        logger.warning('SnapName  : %s' % (self.SnapName))
        logger.warning('SnapLock  : %s' % (self.SnapLock))
        logger.warning('SLockFile : %s' % (self.SLockFile))

        self.parent       = ''
        self.subvolsshort = []
        self.subvolumes   = []
        self.stderr       = args.stderr
        #self.DEBUG(self, '[II]  <%s> is %s: ' % (self.store, self.config.getStorePath(self.store,self.args.tag,original=True)), level=2)
        logger.warning('[II]  <%s> is %s: ' % (self.store, self.config.getStorePath(self.store,self.args.tag,original=True)))
        #self.partstep = (100 / (self.args.mdbpart * self.args.mdbsteps)) / len(self.list_subvolumes(self.id))
        self.partstep = mdbslice / len(self.list_subvolumes(self.id))
        logger.debug("""Steps
        mdpart: %i
        count subvolumes: %i
        len list_subvolumes: %i
        mdparts (mdbpart * mdbsteps): %i
        pparts: %i
        partstep: %f""" % (self.args.mdbpart,
                self.count_subvolumes(self.id),
                len(self.list_subvolumes(self.id)),
                self.args.mdbpart * self.args.mdbsteps,
                100,
                self.partstep))
                #100 / (self.args.mdbpart * self.args.mdbsteps),

    def _createlockfile(self,lf,ln):
        #print(self.args.config.getssh(self.tag,self.store))
        if Myos().path_isfile(self.store+'/'+lf,conn=self.args.config.getssh(self.tag,self.store)):
            logger.warning('Nothing to lock')
            #self.DEBUG('Nothing to lock',level=2)
        else:
            logger.warning("%-12s»<%s>/%s«" % (' =lock>',self.store,ln))
            #self.DEBUG("%-12s»<%s>/%s«" % (' =lock>',self.store,ln),level=0)
            try:
                lockfile = open(self.StorePath+'/'+lf, 'w', 1)
                lockfile.write(str(os.getpid()))
                lockfile.close()
            except OSError as e:
                print('ERROR create lockfile: %s' % (e))
                pass
        return

    def _deletelockfile(self,lf,ln,checked=True):
        path = self.StorePath+'/'
        if checked:
            if check_lockfile(self.args,path+lf):
                #self.DEBUG('ERROR - lockfile in use: <%s - %s>/%s' % (self.store,self.StorePath,path+lf),level=2)
                logger.warning('ERROR - lockfile in use: <%s - %s>/%s' % (self.store,self.StorePath,path+lf))
                return
        try:
            Myos(dry=self.args.dry_run).remove(path+lf,args.config.getssh(self.tag,self.store))
        except OSError as e:
            if e.errno == errno.EEXIST or errno.ENOENT:
                pass
                # if lockfile doesn't exist, continue
                #self.DEBUG('INFO - lockfile is not existing: <%s - %s>/%s' % (self.store,self.StorePath,path+lf),level=2)
            else:
                raise e
        return


    def _rename(self,Action,From,To,store):
        if Action == 'rollback':
            for i in self.config.getVolumes():
                if i.split('.')[0] == From.split('.')[0].lstrip('/'):
                    #print('rollback',Action,'Vol %s: From: %s To: %s' % (i,From,To))
#                raise SystemVolumeError(action=Action)
                    pass
                    #return
        else:
            for i in self.config.getVolumes():
               # print('NOTrollback',Action,'Vol %s: From: %s To: %s' % (i,From,To))
                if From == i:
                    raise RuntimeError('ERROR - Systemvolume not allowed to rename (From): %s' % (From),1)
                elif To == i:
                    raise RuntimeError('ERROR - Systemvolume not allowed to rename (To): %s' % (To),1)
                else:
                    logger.debug('Action "%s" (%s) From: %s or To: %s is ok' % (Action,i,From,To))
                    #self.DEBUG('Action "%s" (%s) From: %s or To: %s is ok' % (Action,i,From,To),level=3)

        st = self.store if store == None else store

        StorePath = self.config.getStorePath(st,self.args.tag)
        if not issubvol(self.args,StorePath,store,self.args.tag):
            logger.debug("Failed to rename »<%s>%s«, is no btrfs-subvolume, or not existing" % (st,From))
            #self.DEBUG("Failed to rename »<%s>%s«, is no btrfs-subvolume, or not existing" % (st,From),level=3)
            return

        logger.debug(' =try-to-rename> »<%s>/%s« --> »%s«' % (st,From,To))
        #self.DEBUG(' =try-to-rename> »<%s>/%s« --> »%s«' % (st,From,To),level=3)
        pass

        logger.info(" =unlock>  <%s>/%s" % (st,To))
        #self.DEBUG(" =unlock>  <%s>/%s" % (st,To),level=1)
        if Myos().path_exists(StorePath+'/'+To,self.args.config.getssh(self.tag,st)):
            logger.info(' =%-10s»%s« exists. Nothing to rename' % (Action+':',To))
            #self.DEBUG(' =%-10s»%s« exists. Nothing to rename' % (Action+':',To),level=3)
            return
        else:
            if self.args.action == 'create':
                if Action == 'lock':
                    logger.debug(" =%-11s nothing to rename" % (Action+':'))
                    #self.DEBUG(" =%-11s nothing to rename" % (Action+':'),level=3)
                    return
            else:
                if issubvol(self.args,StorePath+'/'+From,store,self.args.tag):
                    logger.info(' =%s-rename> »<%s>/%s« --> %s' % (Action,st,From,To))
                    #self.DEBUG(' =%s-rename> »<%s>/%s« --> %s' % (Action,st,From,To), level=1)
                else:
                    return
        try:
            #print('DRY',self.args.dry_run)
            Myos(dry=self.args.dry_run).rename(StorePath+'/'+From,StorePath+'/'+To,self.args.config.getssh(self.tag,store))
        except FileNotFoundError:
            logger.debug('Nothing to rename')
            #self.DEBUG('Nothing to rename',level=3)
        except OSError as e:
            print(e)
        except:
            raise

        return

    def lock(self,store=None):
        store = self.store
        logger.info('try to lock on action %s' % (self.args.action))
        #self.DEBUG('try to lock on action %s' % (self.args.action),level=4)
        try:
            logger.info('Action is %s' % (self.args.action))
            #self.DEBUG('Action is %s' % (self.args.action),level=3)
            if self.args.action == 'create':
                logger.debug(' ++> create lockfile for Snapshot (%s)' % (self.args.action))
                #self.DEBUG(' ++> create lockfile for Snapshot (%s)' % (self.args.action),level=3)
                self._createlockfile(self.SLockFile,self.SnapName)
                pass
            elif self.args.action == 'delete' or self.args.action == 'cleanup':
                logger.debug(' --> delete lockfile for Original (%s)' % (self.args.action))
                #self.DEBUG(' --> delete lockfile for Original (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.OLockFile,self.SourceName)

                self._rename('lock',self.SourceName,self.OrigLock,store)
                pass
            elif self.args.action == 'transfer':
                logger.debug(' --> create lockfile for Original (%s)' % (self.args.action))
                #self.DEBUG(' --> create lockfile for Original (%s)' % (self.args.action),level=3)
                self._createlockfile(self.OLockFile,self.SourceName)
                logger.debug(' --> rename to OrigLock')
                #self.DEBUG(' --> rename to OrigLock',level=3)
                self._rename('lock',self.SourceName,self.OrigLock,store)
                pass
            else:
                logger.debug(' ++> create lockfile for Snapshot (%s)' % (self.args.action))
                #self.DEBUG(' ++> create lockfile for Snapshot (%s)' % (self.args.action),level=3)
                self._createlockfile(self.SLockFile,self.SnapName)
                logger.debug(' --> rename to SnapLock')
                #self.DEBUG(' --> rename to SnapLock',level=3)
                self._rename('lock',self.SnapName,self.SnapLock,store)
                pass
        except RuntimeError as e:
            if e.args[1] > 0:
                raise e
        except:
            raise
        self.scanfs()
        return

    def unlock(self,checked=False,store=None):
        store = self.store
        logger.info('try to unlock on action %s' % (self.args.action))
        #self.DEBUG('try to unlock on action %s' % (self.args.action),level=4)
        try:
            if self.args.action == 'create':
                #print('A')
                logger.info(' --unlock-> %s' % (self.args.action))
                #self.DEBUG(' --unlock-> %s' % (self.args.action),level=4)
                logger.info(' --> delete lockfile from Snapshot (%s)' % (self.args.action))
                #self.DEBUG(' --> delete lockfile from Snapshot (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.SLockFile,self.SnapName,checked=False)
                logger.info(' --> rename to SnapName')
                #self.DEBUG(' --> rename to SnapName',level=3)
                self._rename('unlock',self.SnapLock,self.SnapName,store)
                self._rename('unlock',self.SnapLock,self.SnapName,'BKP')
                pass
            elif self.args.action == 'delete':
                #print('B')
                logger.info(' --> delete lockfile from Original (%s)' % (self.args.action))
                #self.DEBUG(' --> delete lockfile from Original (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.OLockFile,self.SourceName,checked=False)
                logger.info(' --> rename to OrigName')
                #self.DEBUG(' --> rename to OrigName',level=3)
                self._rename('unlock',self.OrigLock,self.OrigName,store)
                pass
            elif self.args.action == 'transfer':
                #print('C')
                logger.info(' --> delete lockfile from Original (%s)' % (self.args.action))
                #self.DEBUG(' --> delete lockfile from Original (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.OLockFile,self.SourceName,checked=False)
                logger.info(' --> (%s) rename to OrigName' % (self.args.action))
                #self.DEBUG(' --> (%s) rename to OrigName' % (self.args.action),level=3)
                self._rename('unlock',self.OrigLock,self.OrigName,store)
                self._rename('unlock',self.OrigLock,self.OrigName,'BKP')
                pass
            if self.args.action == 'rollback':
                #print('D')
                logger.info(' --unlock-> %s' % (self.args.action))
                #self.DEBUG(' --unlock-> %s' % (self.args.action),level=4)
                logger.info(' --> delete lockfile from Snapshot (%s)' % (self.args.action))
                #self.DEBUG(' --> delete lockfile from Snapshot (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.SLockFile,self.SnapName,checked=False)
                logger.info(' --> rename to SnapName')
                #self.DEBUG(' --> rename to SnapName',level=3)
                #print('XXX',self.SnapLock,self.SnapName,self.SysVol,self.SysVolOld)
                # rollback snapshot from old snapshot to current volume
                self._rename('rollback',self.SnapLock,self.SnapName,store)
                # rename current sysvolume to oldcurrent
                self._rename('rollback',self.SysVol,self.SysVolOld,store)
                #self._rename('unlock',self.SnapLock,self.SnapName,'BKP')
                pass
            else:
                #print('E')
                logger.info(' --> delete lockfile from Snapshot (%s)' % (self.args.action))
                #self.DEBUG(' --> delete lockfile from Snapshot (%s)' % (self.args.action),level=3)
                self._deletelockfile(self.SLockFile,self.SnapName)
                logger.info(' --> rename to SnapName')
                #self.DEBUG(' --> rename to SnapName',level=3)
                self._rename('unlock',self.SnapLock,self.SnapName,store)
                pass
        except Exception as e:
            logger.warning(e)
            #DEBUG(e)
            raise e
        except:
            raise
        self.scanfs()
        return

#
    def tr_att(self,att):
        if att in self.translate:
            return self.translate[att]
        else:
            return att

    def setprop(self,ro=True):
        if self.args.action == 'create':
            sname = self.SnapLock
        elif self.args.action == 'setprop':
            sname = self.OrigName
        else:
            sname = self.OrigLock

        for i in self.config.getVolumes():
            if sname == i and ro == True:
                raise RuntimeError('ERROR - Systemvolume not allowed to set read-only: %s' % (sname),1)

        propn = 'ro' if ro else 'rw'
        prop = 'true' if ro else 'false'
        logger.info(' =set-%-6s»<%s>/%s«' % (propn+'>',self.store,sname))
        #self.DEBUG(' =set-%-6s»<%s>/%s«' % (propn+'>',self.store,sname),level=1)
        for sub in self.list_subvolumes(self.id,names=True,rev=True if ro else False):
            if issubvol(self.args,self.StorePath+'/'+sname+'/'+sub,self.store,self.args.tag):
                logger.info('  =%-9s»<%s>/%s«' % (propn+'>',self.store,sname+'/'+sub))
                #self.DEBUG('  =%-9s»<%s>/%s«' % (propn+'>',self.store,sname+'/'+sub),level=1)
                try:
                    cmd = ['btrfs','property','set','-ts',self.StorePath+'/'+sname+'/'+sub,'ro',prop]
                    self.args.config.remotecommand(tag=self.args.tag, store=self.store, cmd=cmd)
                except:
                    logger.info('setprop error')
                    #self.DEBUG('setprop error',level=1)

            else:
                pass

    def create(self):
        logger.warning(' =create-snapshot=> from »<%s>/%s«' % (self.store, self.SourceName))
        #self.DEBUG(' =create-snapshot=> from »<%s>/%s«' % (self.store, self.SourceName),level=1)
        #compile regular expression for ignoring subvolume-names
        if self.args.ignore == None:
            if not self.config.getIgnores(self.args.tag) == None:
                re_ign = re.compile('|'.join(self.config.getIgnores(self.args.tag).split(',')))
            else:
                re_ign = None
        else:
            re_ign = re.compile('|'.join(self.args.ignore))
        logger.debug('Ignores for %s: %s' % (self.tag, re_ign))
        if self.args.npb: pt = progress_timer(description= ' =create-snapshot=> from »<%s>/%s«: ' % (self.store, self.SourceName), n_iter=len(self.list_subvolumes(self.id,names=True)))
        if issubvol(self.args,self.StorePath+'/'+self.SourceName,self.store,self.args.tag):
            try:
                for sub in self.list_subvolumes(self.id,names=True):
                    # Test if subvolume is in ignorelist - only debug-output now
                    if re_ign != None and re_ign.search('/'+sub):
                        logger.info('%-12s»<%s>/%s«:' % (' -IGNORE->',self.store, sub))
                        #self.DEBUG('%-12s»<%s>/%s«:' % (' -IGNORE->',self.store, sub),level=2)
                        self.args.mdb.update(self.args.tag,self.partstep )
                    else:
                        # Test the Source for local snapshotting
                        if issubvol(self.args,self.StorePath+'/'+self.SourceName+'/'+sub,self.store,self.args.tag):
                            dest = self.SnapLock+'/'+sub
                            #TODO: Test on ignores
                            cmd = ['btrfs','subvolume','snapshot',self.StorePath+'/'+self.SourceName+'/'+sub,self.StorePath+'/'+dest]

                            # Test the destination for local snapshotting
                            if issubvol(self.args,self.StorePath+'/'+dest,self.store,self.args.tag):
                                # Test if top level snapshot is existing and a snapshot
                                logger.info(dest,self.StorePath+'/'+dest,self.store,self.args.tag)
                                #self.DEBUG(dest,self.StorePath+'/'+dest,self.store,self.args.tag,level=1)
                                raise RuntimeError('FAILURE - Destination exists: %s' % (self.StorePath+'/'+dest), 0)
                            elif issubvol(self.args,self.StorePath+'/'+dest,self.store,self.args.tag) == False:
                                # If destination exists and is a directory and not a snapshot, delete dir and create snapshot (for subvolumes of snapshot)
                                logger.info('%-12s»<%s>/%s«' % (' =create>',self.store,dest))
                                #self.DEBUG('%-12s»<%s>/%s«' % (' =create>',self.store,dest),level=1)
                                output = self.args.config.remotecommand(tag=self.args.tag, store=self.store, cmd=['rm','-r','-f',self.StorePath+'/'+dest])
                                output = self.args.config.remotecommand(tag=self.args.tag, store=self.store, cmd=cmd)
                            else:
                                # If destination doesnt exist, create the snapshot
                                logger.info('%-12s»<%s>/%s«' % (' =create>',self.store,dest))
                                #self.DEBUG('%-12s»<%s>/%s«' % (' =create>',self.store,dest),level=1)
                                output = self.args.config.remotecommand(tag=self.args.tag, store=self.store, cmd=cmd)
                            sync()

                        elif issubvol(self.args,self.OrigName+'/'+sub,self.store,self.args.tag) == False:
                            raise RuntimeError('FAILURE - Source is directory, not a subvolume. No creation possible: %s' % (sub), 0)
                        else:
                            logger.info( " Source-subvolume not existing: %s" % (self.OrigName+'/'+sub))
                            #self.DEBUG( " Source-subvolume not existing: %s" % (self.OrigName+'/'+sub),level=3)
                    if self.args.npb: pt.update()
                    self.args.mdb.update(self.args.tag,self.partstep )
                else:
                    if self.args.npb: pt.update()
                    self.args.mdb.update(self.args.tag,self.partstep )
                    pass
                if self.args.npb: pt.finish()
                self.snapped = True

                self.scanfs() #rescan filesystem after creating the new snapshots
                ex = re.compile(self.SnapLock+'$')
                for i in self.grep_volume(ex,names=False,rev=True):
                    logger.info('SnapID,SnapName %s %s'%(self.svols[i]['id'],self.svols[i]['path']))
                    #self.DEBUG('SnapID,SnapName %s %s'%(self.svols[i]['id'],self.svols[i]['path']),level=5)
                    self.SnapID = self.svols[i]['id']
                    BtrfsListing.CreatedSubvolumes.push((self.store,self.SnapName))
                    return(list([self.svols[i]['id'],self.svols[i]['path']]))

                raise CreateError('FAILURE - create new snapshot failed %s' % (self.SnapLock), 0)
            except:
                raise CreateError
            #return(self.SnapLock)
        else:
            if self.args.npb: pt.finish()
            logger.critical('[EE] creation not possible: original not existing: %s' % (self.SourceName),level=0)
            #self.DEBUG('[EE] creation not possible: original not existing: %s' % (self.SourceName),level=0)
            raise CreateError('ERROR no snapshot - original not existing: %s' % (self.SourceName))
        if self.args.npb: pt.finish()


    def transfer(self):
        if self.config.getTransfer(self.tag) or self.args.action == 'transfer':
            if self.args.action == 'create':
                sname = self.SnapLock
                sid = self.SnapID
            else:
                sname = self.OrigLock
                sid = self.id


            #get uuids of SNP/SRC and BKP and compare. If they are the same, no transfer, if they are different, make transfer to external media
            #print(self.config.getDevice(store='BKP'))
            try:
                uuidS = self.config.getUUID(store=self.store,tag=self.args.tag)
            except FileNotFoundError:
                logger.critical(" |no-transfer: directory for »%s« not existing: »%s«" % (self.store,self.config.getMountPath(store=self.store,tag=args.tag)))
                #self.DEBUG(" |no-transfer: directory for »%s« not existing: »%s«" % (self.store,self.config.getMountPath(store=self.store,tag=args.tag)))
                return
            except:
                uuidS = None

            try:
                uuidB = self.config.getUUID(store='BKP',tag=self.args.tag)
            except FileNotFoundError:
                logger.critical(" |no-transfer: directory for »%s« not existing: »%s«" % ('BKP',self.config.getMountPath(store='BKP',tag=args.tag)))
                return
            except:
                uuidB = None

            logger.debug("UUID-compare %s %s" % (uuidS,uuidB))
            #self.DEBUG("UUID-compare",uuidS,uuidB,level=4)
            if None == uuidS:
                logger.critical(" |no-transfer: Filesystem for »%s« not mounted: »%s«" % (self.store,self.config.getDevice(store=self.store,tag=args.tag)))
                return
            if None == uuidB:
                logger.critical(" |no-transfer: Filesystem for »%s« not mounted: »%s«" % ('BKP',self.config.getMountPath(store='BKP',tag=args.tag)))
                return

            if uuidS == uuidB:
                # Same Filesystem on SRC/SNP and BKP. No transfer
                logger.critical(" |no-transfer: external backupmedia obviously not mounted")
                return
            else:
                # Test if path to external backup-store is a btrfs-subvolume. if not, no transfer
                # first check if BKP-mount is btrfs, then check if BKP-Store exists and is a subvolume.
                # If BKP-mount is btrfs, and BKPStore does not exist, create it as subvolume
                # If BKPStore exists and is a directory, change it to subvolume
                if self._isbtrfs(self.config.getMountPath(store='BKP',tag=args.tag,original=False),'BKP',args.tag):
                    if Myos().path_exists(self.BkpPath,self.args.config.getssh(self.args.tag,'BKP')):
                        if issubvol(self.args,self.BkpPath,'BKP',self.args.tag):
                            logger.debug("BKP-Path %s is subvolume" % (self.BkpPath))
                        else:
                            logger.critical(" |no-transfer: %s should be subvolume, is directory on external media" % (self.BkpPath))
                            return
#                           # TODO move ro-subvolumes to another place... this code is not working
#                            try:
#                                print("%s exists; is directory" % (self.BkpPath))
#                                print("%s -> change to subvolume, this may take a while" % (self.BkpPath))
#                                # rename original BKPStore
#                                print('A ren')
#                                cmd = ['mv',self.BkpPath,self.BkpPath+'.orig']
#                                sp_call(self.args,cmd)
#                                # Create a new Subvolume
#                                print('B cr')
#                                cmd = ['btrfs','subvolume','create',self.BkpPath]
#                                sp_call(self.args,cmd)
#                                # move content to new snapshot
#                                print('C mv')
#                                cmd = ['mv',self.BkpPath+'.orig/*',self.BkpPath]
#                                sp_call(self.args,cmd)
#                                # delete old directory
#                                print('D rm')
#                                cmd = ['rm','-rf',self.BkpPath+'.orig']
#                                sp_call(self.args,cmd)
#                                print('E')
#                            except:
#                                return

                    else:
                        print('%s not exists -> create subvolume' % (self.BkpPath))
                        logger.debug('isdir ==> delete ==> transfer',self.BkpPath)
                        #self.DEBUG('isdir ==> delete ==> transfer',self.BkpPath,level=3)
                        cmd = ['btrfs','subvolume','create',self.BkpPath]
#                        sp_call(self.args,cmd)
                        self.args.config.remotecommand(tag=self.args.tag, store='BKP', cmd=cmd)
                else:
                    logger.info(' |no-transfer: no subvolume for backup on external media')
                    #self.DEBUG(' |no-transfer: no subvolume for backup on external media')
                    return

            BKP = BtrfsListing(self.args,store='BKP')
            transfers = dict()
            regexpart = re.compile('\.part$|\.part/')

            if self.args.action == 'transfer':
                self.scanfs() #update btrfs-list in memory

            clones = dict() #clone list
            if not self.args.no_clones:
                for par in self.grep_volume(re.compile('^'+self.OrigName.split('.')[0]+'\.'),names=False):
                    for bsub in sorted(BKP.svols):
                        if BKP.svols[bsub]['path'] == self.svols[par]['path'] and not regexpart.search(self.svols[par]['path']):
                            subbasename = re.sub('^'+self.svols[par]['path'].split('/')[0],self.basename,self.svols[par]['path'])
                            if not subbasename in clones:
                                clones[subbasename] = list()
                            clones[subbasename].append(self.svols[par]['path'])
                            logger.debug("Add to clones",self.svols[par]['path'],"->",subbasename)
                            #self.DEBUG("Add to clones",self.svols[par]['path'],"->",subbasename,level=4)

            for sub in self.list_subvolumes(sid,names=False):
                plist = dict() #parent list
                for sis in self.list_sisters(self.svols[sub]['id'],older=True,younger=False,names=False,rev=False):
                    for bsub in sorted(BKP.svols):
                        if BKP.svols[bsub]['ruuid'] == self.svols[sis]['uuid']:
                            plist[self.svols[sis]['id']] = self.svols[sis]['id']


                transfers[self.svols[sub]['path']] = dict()
                if len(plist) > 0:
                    v=[int(i) for i in plist.values()]
                    k=list(plist.keys())
                    parent = k[v.index(max(v))]
                    transfers[self.svols[sub]['path']]['parent'] = self.svols[parent]['path']
                    logger.info("%s id: %s" % (self.svols[parent]['path'],k))
                    #self.DEBUG(self.svols[parent]['path'],"id: ",k,level=3)
                else:
                    pass

                if len(clones) > 0:
                    bsubvol = re.sub('^'+self.svols[sub]['path'].split('/')[0],
                            self.basename,
                            self.svols[sub]['path'])
                    if bsubvol in clones:
                        transfers[self.svols[sub]['path']]['clone'] = clones[bsubvol]

            logger.info(' ==transfer=> »<%s>/%s«' % (self.store,sname))
            #self.DEBUG(' ==transfer=> »<%s>/%s«' % (self.store,sname),level=1)
            if self.args.npb: pt = progress_timer(description= ' ==transfer=> »<%s>/%s«: ' % (self.store,sname), n_iter=len(transfers.keys())*2)
            for t in sorted(transfers.keys()):
                dest = args.config.getStorePath('BKP',args.tag)+'/'+t
                destdir = os.path.dirname(dest.rstrip('/'))+'/'
                if issubvol(self.args,dest,self.store,self.args.tag) == False:
                    if Myos().path_exists(dest,self.args.config.getssh(self.args.tag,'BKP')):
                        logger.info('isdir ==> delete ==> transfer %s' % (dest))
                        #self.DEBUG('isdir ==> delete ==> transfer',dest,level=3)
                        cmd = ['rm','-r','-f',dest]
                        #sp_call(self.args,cmd)
                        self.args.config.remotecommand(tag=self.args.tag, store='BKP', cmd=cmd)
                    else:
                        pass
                        logger.info('notexist ==> transfer %s' %( dest))
                        #self.DEBUG('notexist ==> transfer', dest,level=3)
                else:
                    logger.info('ignored: subvolume »%s« exists in »%s«' % (t,destdir))
                    #self.DEBUG('ignored: subvolume »%s« exists in »%s«' % (t,destdir),level=2)
                    continue

                try:
                    self.send_receive(
                            t,
                            destdir,
                            parent=transfers[t]['parent'] if 'parent' in transfers[t] else None,
                            clone=transfers[t]['clone'] if 'clone' in transfers[t] else None)
                    self.transferred = True
                except TransferError:
                    raise TransferError

                if self.args.npb: pt.update()
                self.args.mdb.update(self.args.tag,self.partstep )
                try:
                    cmd = ['btrfs','property','set','-ts',dest,'ro','false']
                    X = self.args.config.remotecommand(tag=self.args.tag, store='BKP', cmd=cmd)
                except:
                    raise TransferError

            BtrfsListing.TransferedSubvolumes.push(re.sub('\.part$','',sname))
            for t in reversed(sorted(transfers.keys())):
                dest = args.config.getStorePath('BKP',args.tag)+'/'+t
                destdir = os.path.dirname(dest.rstrip('/'))+'/'
                logger.info("  =set-ro>  %s" % (dest))
                #self.DEBUG("  =set-ro>  %s" % (dest),level=1)
                try:
                    cmd = ['btrfs','property','set','-ts',dest,'ro','true']
                    #sp_call(self.args,cmd,level=2)
                    self.args.config.remotecommand(tag=self.args.tag, store='BKP', cmd=cmd)
                    if self.args.npb: pt.update()
                except:
                    raise TransferError
            if self.args.npb: pt.finish()
            return(sname)

    def send_receive(self,source,dest,parent=None,clone=None):
        tclones, tparent = list(), list()
        if parent == None:
            if clone == None:
                logger.info('%-20s»<%s>/%s«' % ('  =initial transfer=>',self.store,source))
                #self.DEBUG('%-20s»<%s>/%s«' % ('  =initial transfer=>',self.store,source),level=1)
            else:
                for x in sorted(clone):
                    tclones.append('-c')
                    tclones.append(self.StorePath + '/' + x)
                logger.info('%-20s»<%s>/%s« <-clone: %s' % ('  =incr-clone transfer=> ',self.store,source,' '.join(tclones)))
                #self.DEBUG('%-20s»<%s>/%s« <-clone: %s' % ('  =incr-clone transfer=> ',self.store,source,' '.join(tclones)),level=1)
        else:
            if clone != None:
                logger.info('%-20s»<%s>/%s« <-parent: %s + clones' % ('  =incr transfer=> ',self.store,source,parent))
                #self.DEBUG('%-20s»<%s>/%s« <-parent: %s + clones' % ('  =incr transfer=> ',self.store,source,parent),level=1)
                for x in sorted(clone):
                    tclones.append('-c')
                    tclones.append(self.StorePath + '/' + x)
            else:
                logger.info('%-20s»<%s>/%s« <-parent: %s' % ('  =incr transfer=> ',self.store,source,parent))
                #self.DEBUG('%-20s»<%s>/%s« <-parent: %s' % ('  =incr transfer=> ',self.store,source,parent),level=1)
            tparent = ['-p',self.StorePath+'/'+parent]

        first = ['btrfs','send'] + tclones + tparent + [self.StorePath+'/'+source]
        second = ['btrfs','receive',dest]

        ssh = self.args.config.getSsh(self.tag)
        if ssh[self.store] != None:
            send=ssh[self.store]['user']+'@'+ssh[self.store]['host']
            first = ['ssh','-p',str(ssh[self.store]['port']),send]+first
        else:
            send='local'

        if ssh['BKP'] != None:
            recv=ssh['BKP']['user']+'@'+ssh['BKP']['host']
            second = ['ssh','-p',str(ssh['BKP']['port']),recv]+second
        else:
            recv='local'


        #output = args.config.remotecommand(tag=args.tag, store=store, cmd=cmd)

        if not self.args.transferinfo:
#            print("S->R",first,second)
#            stdin_send,stdout_send,stderr_send = cmdsh(self.tag,self.store,first)
#            stdin_recv,stdout_recv,stderr_recv = cmdsh(self.tag,'BKP',second)
            try:
                logger.info(' '.join(first)+' | '+' '.join(second))
                #self.DEBUG(' '.join(first)+' | '+' '.join(second),level=3)
                process_send = subprocess.Popen(first, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
                                                shell=False)
                process_recv = subprocess.Popen(second, stdin=process_send.stdout, stderr=subprocess.DEVNULL,
                                              stdout=subprocess.PIPE, shell=False)
                # Allow process_curl to receive a SIGPIPE if process_send exits.
                process_send.stdout.close()
                out, err = process_recv.communicate()
                #self.DEBUG("out --- err",out," --- ",err,level=3)
            except:
                raise TransferError('ERROR - sending to external backup-media failed')
                pass
            return(out.decode('utf8').split('\n'))
        else:
            logger.info('no transfer - only information')
            #self.DEBUG('no transfer - only information')
            return

    def symlink_force(self,target, link_name, store):
        cmd=['ln','-s','-f', '-n', target, link_name]
        self.args.config.remotecommand(tag=self.args.tag, store=store, cmd=cmd)
        logger.info("[II] TARGET => LINKNAME: %s => %s" % (target.strip(),link_name.strip()))
        #self.DEBUG("[II] TARGET => LINKNAME: %s => %s" % (target.strip(),link_name.strip()),level=3)

#        try:
#            os.symlink(target, link_name)
#        except OSError as e:
#            if e.errno == errno.EEXIST:
#                    os.remove(link_name)
#                    os.symlink(target, link_name)
#                    self.DEBUG("[II] TARGET => LINKNAME: %s => %s" % (target.strip(),link_name.strip()),level=3)
#            else:
#                raise e

    def symlink(self):
        for st in list(self.args.sourcepath.keys())[0], list(self.args.destpath.keys())[0]:
            StorePath = self.config.getStorePath(st,self.args.tag)
            if not issubvol(self.args,StorePath,st,self.args.tag): continue
            linkName = self.basename+'.'+args.config.getSymLink(args.tag)
            logger.info('%-12s =>»<%s>/%s«' % (' =symlink>',st,linkName))
            #self.DEBUG('%-12s =>»<%s>/%s«' % (' =symlink>',st,linkName),level=0)
            self.symlink_force('./'+self.SnapName, StorePath+'/'+linkName,st)
            if args.config.getSymLink(args.tag) != args.config.getSymLink():
                logger.info('%-12s =>»<%s>/%s«' % (' =symlink>',st,self.basename+'.LAST'))
                #self.DEBUG('%-12s =>»<%s>/%s«' % (' =symlink>',st,self.basename+'.LAST'),level=0)
                self.symlink_force('./'+self.SnapName, StorePath+'/'+self.basename+'.LAST',st)

    def symlink_sysvol(self):
        for st in list(self.args.sourcepath.keys())[0], list(self.args.destpath.keys())[0]:
            StorePath = self.config.getStorePath(st,self.args.tag)
            if not issubvol(self.args,StorePath,st,self.args.tag): continue
            #linkName = self.basename+'.'+args.config.getSymLink(args.tag)
            linkName = self.basename
            logger.info('%-12s =>»<%s>/%s«' % (' =symlink>',st,linkName))
            #self.DEBUG('%-12s =>»<%s>/%s«' % (' =symlink>',st,linkName),level=0)
            self.symlink_force('./'+self.SnapName, StorePath+'/'+linkName,st)
#            if args.config.getSymLink(args.tag) != args.config.getSymLink():
#                self.DEBUG('%-12s =>»<%s>/%s«' % (' =symlink>',st,self.basename+'.LAST'),level=0)
#                self.symlink_force('./'+self.SnapName, StorePath+'/'+self.basename+'.LAST',st)

    def delete(self):
        logger.info('%-20s from »<%s>/%s«' % (' =delete-snapshot=>',self.store, self.SourceName))
        #self.DEBUG('%-20s from »<%s>/%s«' % (' =delete-snapshot=>',self.store, self.SourceName),level=1)
        if self.args.action == 'somethingelse':
            sname = self.SnapLock
            slock = self.SLockFile
            sid = self.SnapID
        else:
            sname = self.OrigLock
            slock = self.OLockFile
            sid = self.id


        #print('delete %s - %s with %s and action %s' % (sname,sid,slock,self.args.action))

        for i in self.config.getVolumes():
            #print(i,sname,i+'.part')
            if ( sname == i or sname == i+'.part' ):
                raise RuntimeError('ERROR - Systemvolume not allowed to delete: %s' % (sname),1)
                return

        if self.args.npb: pt = progress_timer(description= ' =delete-snapshot=> from »<%s>/%s«: ' % (self.store, self.SourceName), n_iter=len(self.list_subvolumes(self.id,names=True)))
        delsubs = []
        if issubvol(self.args,self.StorePath+'/'+sname,self.store,self.args.tag):
            for sub in self.list_subvolumes(sid,names=True,rev=True,incl_self=True):
                issub = issubvol(self.args,self.StorePath+'/'+sname+'/'+sub,self.store,self.args.tag)
                if issub == None:
                    logger.info('del - not existing: '+self.StorePath+'/'+sname+'/'+sub)
                    #self.DEBUG('del - not existing: '+self.StorePath+'/'+sname+'/'+sub,level=3)
                    pass
                else:
                    if issub:
                        if not Myos().path_isfile(self.StorePath+'/'+slock,self.args.config.getssh(self.tag,self.store)):
                            logger.info(' -prepare-to-delete> <%s>/%s' % (self.store,sname+'/'+sub))
                            #self.DEBUG(' -prepare-to-delete> <%s>/%s' % (self.store,sname+'/'+sub),level=1)
                            delsubs.append(self.StorePath+'/'+sname+'/'+sub)
                        else:
                            logger.info('del - subvolume is locked: '+self.dir+'/'+sname+'/'+sub)
                            #self.DEBUG('del - subvolume is locked: '+self.dir+'/'+sname+'/'+sub,level=3)
                        pass
                    else:
                        logger.info('del - dir: '+self.dir+'/'+sname+'/'+sub)
                        #self.DEBUG('del - dir: '+self.dir+'/'+sname+'/'+sub,level=3)
                        pass

            if self.args.action == 'create' or self.args.action == 'cleanup':
                self.setprop(ro=False)
            if len(delsubs) > 0:
                cmd = ['btrfs','subvolume','delete','-c']
                cmd.extend(delsubs)
                logger.info(' -delete-subvolumes>')
                #self.DEBUG(' -delete-subvolumes>',level=1)
                try:
                    #sp_call(self.args,cmd)
                    self.args.config.remotecommand(tag=self.args.tag, store=self.store, cmd=cmd)
                    logger.info(' -subvolumes-deleted>')
                    #self.DEBUG(' -subvolumes-deleted>',level=1)
                    #linkName = self.basename+'.'+args.config.getSymLink(args.tag)
                    BtrfsListing.DeletedSubvolumes.push((self.store,re.sub('\.part$','',sname)))
                    self.del_vol    = self.OrigName.split('.')[0]
                    self.del_ts     = self.OrigName.split('.')[1]
                    self.del_tag    = self.OrigName.split('.')[2]
                except:
                    raise DeleteError

            else:
                logger.info('del - no subvolumes registered')
                #self.DEBUG('del - no subvolumes registered',level=0)
        if self.args.npb: pt.update()

        if self.args.npb: pt.finish()


    def main(self):
            #print(self.svols)
            #print(self.list_sisters(self.ID))
        #try:
            self.parse_btrfs_show()
    #        self.read_subvolumes(self.storename+'/'+self.name)
        #except:
        #    print("Snapshot does not exist: <%s>/%s" % (self.store,self.name))
        #    return(self.exist)

def main(args):
    for st in args.store:
        print('S',args.config.getStorePath(st,args.tag))
        for s in args.snapshots:
            print(st,s)

            L=SubVolume(args,s,store=st)
            L.list_sisters(L.id,rev=True)
            #L.main()
            #L.list_sisters()
            #X=SubVolume(BtrfsListing)

def issubvol(args,path,store='SRC',tag=None):
    #print("issubvol-store",store,tag,path)
    if not path == None:
        cmd = ['stat', '-c', '%i', path ]
        try:
            return True if int(args.config.remotecommand(tag=args.tag, store=store, cmd=cmd, stderr=subprocess.DEVNULL)) == 256 else False
        except:
            return False
        return True if int(output) == 256 else False



def cleanup(args):
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    logger.info(' --== cleanup ==-->')
    #DEBUG(' --== cleanup ==-->',verbose=args.verbose,level=1)
    #self.partstep = (100 / (args.mdbpart * args.mdbsteps)) / len(self.list_subvolumes(self.id))
    if args.npb: pt = progress_timer(description= ' --== cleanup ==-->', n_iter=6)
    args.action = 'cleanup'
    #DEL = dict()
    DEL = Stack()
    ST = dict()
    explock = re.compile('.*.~lock$')
    exppart = re.compile('.part$')
    partlock = dict()
    cI,I = dict(), dict()
    for i in args.config.ListIntervals():
        cI[i] = 0
        I[i]  = args.config.getInterval(i)
    #for st in args.store:
    for st in ['SRC','SNP','BKP']:
        StorePath = args.config.getStorePath(st,args.tag)
        if not issubvol(args,StorePath,st,args.tag):
            logger.info(' =cleanup: store doesnt exist: %s' % (StorePath))
            #DEBUG(args,' =cleanup: store doesnt exist: %s' % (StorePath),level=3)
            continue
            if args.npb: pt.update()
        else:
            logger.info(' -Cleanup store <%s>:%s' % (st,StorePath))
            #DEBUG(args,' -Cleanup store <%s>:%s' % (st,StorePath),level=3)
            StorePath = args.config.getStorePath(st,args.tag)+'/'
            ST[st] = BtrfsListing(args,store=st,single=True)
            if len(args.snapshots) > 0:
                logger.info('  --cleanup interval-snapshots')
                #DEBUG(args,'  --cleanup interval-snapshots',level=3)
                for sn in [v.partition('.current')[0] for v in args.snapshots]:
                #for sn in args.snapshots:
                    ex = re.compile('$|'.join([sn+'\..*\.' + word_in_list for word_in_list in I.keys()])+'$')
                    logger.debug('Regex: %s' % (ex))
                    #DEBUG(args,'Regex:',ex,level=5)
                    for i in args.config.ListIntervals():
                        cI[i] = 0
                    try:
                        for i in ST[st].grep_subvolumes(ex,names=False,rev=True):
                            for tag in I.keys():
                                if ST[st].svols[i]['path'].partition('.'+tag)[1] != '':
                                    cI[tag] += 1
                                    if cI[tag] > int(I[tag]):
                                        DEL.push([st,ST[st].svols[i]['path']])
                    except:
                        raise CleanupError('cleanup failed for %s' % (sn))

            # Find unused lockfiles and delte them also
            logger.info('  --cleanup *.part$-Snapshots')
            #DEBUG(args,'  --cleanup *.part$-Snapshots',level=3)
            for i in ST[st].svols:
                subvol = ST[st].svols[i]['path']
                if exppart.search(subvol):
                    DEL.push([st,subvol])

            # Delete them
            while not DEL.is_empty():
                print("DEL len: ", DEL.len())
                S = DEL.pop()
                try:
                    L=SubVolume(args,S[1],store=S[0], mdbslice=args.mdbslice / (DEL.len() + 1))
                    L.lock()
                    L.delete()
                except NoSubvolumeError:
                    continue
                except:
                    raise
            if args.npb: pt.update()

            logger.info('  --cleanup unused lockfiles')
            #DEBUG(args,'  --cleanup unused lockfiles',level=3)
            for lf in Myos().listdir(args.config.getStorePath(st,args.tag),args.config.getssh(args.tag,st)):
                if explock.search(lf):
                    if check_lockfile(args,lf):
                        pass
                    elif check_lockfile(args,lf) == None:
                        pass
                    else:
                        logger.info(' --> remove unused lockfile: '+lf)
                        #DEBUG(' --> remove unused lockfile: '+lf,level=1,verbose=args.verbose)
                        Myos(dry=args.dry_run).remove(lf,args.config.getssh(args.tag,st))
            if args.npb: pt.update()

    if args.npb: pt.finish()
    return

def create(args):
    SRC=dict()
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    for snap in args.snapshots:
        try:
            SRC[snap] = SubVolume(args,snap,store=list(args.sourcepath.keys())[0], mdbslice=args.mdbslice)
            SRC[snap].create()
            SRC[snap].lock()
            SRC[snap].setprop(ro=True)
            SRC[snap].transfer()
            SRC[snap].unlock()
            SRC[snap].symlink()
        except RuntimeError as e:
            if e.args[1] == 0:
                print('nicht so schlimm')
            else:
                raise e
        except (NoSubvolumeError, NoBtrfsVolumeError):
            print("Create Error: %s not found -> continue" % (snap))
            pass
        except:
            raise
    cleanup(args)
    return

def rollback(args):
    SRC=dict()
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    for snap in args.snapshots:
        try:
            SRC[snap] = SubVolume(args,snap,store=list(args.sourcepath.keys())[0])
            SRC[snap].create()
            SRC[snap].lock()
            SRC[snap].setprop(ro=False)
            #SRC[snap].transfer()
            SRC[snap].unlock()
            SRC[snap].symlink_sysvol()
            #SRC[snap].rename()
        except RuntimeError as e:
            if e.args[1] == 0:
                print('nicht so schlimm')
            else:
                raise e
        except (NoSubvolumeError, NoBtrfsVolumeError):
            print("Create Error: %s not found -> continue" % (snap))
            pass
        except:
            raise
    cleanup(args)
    return

def delete(args):
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    for st in args.sourcepath.keys():
        SRC=dict()
        for snap in args.snapshots:
            try:
                SRC[snap] = SubVolume(args,snap,store=st)
                SRC[snap].lock()
                SRC[snap].setprop(ro=False)
                SRC[snap].delete()
            except RuntimeError as e:
                if e.args[1] == 0:
                    print("delete error - nicht so schlimm")
                else:
                    raise e
            except (NoSubvolumeError, NoBtrfsVolumeError):
                print("Delete Error: <%s> %s not found -> continue" % (st,snap))
                pass
            except:
                raise
    return

def setprop(args):
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    for st in args.sourcepath.keys():
        SRC=dict()
        for snap in args.snapshots:
            try:
                SRC[snap] = SubVolume(args,snap,store=st)
                SRC[snap].lock()
                SRC[snap].setprop(ro=args.ro)
                SRC[snap].unlock()
            except RuntimeError as e:
                print(e.args,e.args[1])
                if e.args[1] == 0:
                    print("setprop error - nicht so schlimm")
                else:
                    raise e
            except (NoSubvolumeError, NoBtrfsVolumeError):
                print("Setprop Error: <%s> %s not found -> continue" % (st,snap))
                pass
            except:
                raise
    return

def lists(args):
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    if args.info:
        if args.showpathstore:
            for st in args.store: print(args.config.getStorePath(st,args.tag,original=True))
        if args.showtags:
            for i in args.config.ListIntervals(): print(i)
        if args.showtransfers:
            if args.config.getTransfer(intv=args.tag):
                logger.info('"%s" results in "%s", will transfer actual snapshots from this volume(s):' % (args.tag,args.config.getIsDefault(intv=args.tag)))
                #DEBUG('"%s" results in "%s", will transfer actual snapshots from this volume(s):' % (args.tag,args.config.getIsDefault(intv=args.tag)),level=1,verbose=args.verbose)
                print(' '.join(args.config.getVolumes(tag=args.tag)))
            else:
                logger.info('%s will transfer nothing' % (args.tag))
                #DEBUG('%s will transfer nothing' % (args.tag),level=1,verbose=args.verbose)
#        if args.showdb:
#            cursor = args.conn.execute("SELECT ID, INTNAME, VOL, SNAPNAME, SNAP_TS, TRNS_TS, DELETED  from JOURNAL")
#            print("Journal")
#            tabstr = "%-4s%-12s %-22s  %50s | %-19s - %19s\t%s"
#            print( tabstr % ("ID","Interval","Volume", "SNAMPNAME","Last run","Last Trans","Deleted"))
#            for row in cursor:
#                print(tabstr % (str(row[0])+':',row[1],row[2],'»'+row[3]+'«',row[4],row[5],row[6]))

        if args.print_config:
            args.config.PrintConfig(tag = None if args.tagset else args.tag, of=args.of)

        if args.showyoungest:
            ST=dict()
            for st in args.store:
                ST[st]=dict()
                #for vol in args.config.getVolumes():
                for vol in args.snapshots if len(args.snapshots) > 0 else '*':
                    #print('VOL',vol)
                    ST[st][vol]=dict()
                    for intv in args.config.ListIntervals():
                        ST[st][vol][intv] = dict()
                    if args.config.getStorePath(st,args.tag) is not None:
                        dirlist = dict()
                        for snps in glob.glob(args.config.getStorePath(st,args.tag)+'/'+vol+'.*'):
                            #print("snps",snps)
                            if len(os.path.basename(snps).split('.')) == 3:
                                if not os.path.basename(snps).split('.')[1] in dirlist:
                                    dirlist[os.path.basename(snps).split('.')[1]] = list()
                                dirlist[os.path.basename(snps).split('.')[1]].append(os.path.basename(snps))
                        for t in sorted(dirlist.keys()):
                            for snp in dirlist[t]:
                                #print("T",dirlist[t],snp)
                                for intv in ST[st][vol].keys():
                                    R = re.compile(intv +'$')
                                    #print("I",intv)
                                    if R.search(snp):
                                        #print("snp",st,vol,intv,snp)
                                        #ST[st][vol][intv].append(os.path.basename(snp))
                                        #print(intv,snp,os.path.basename(snps).split('.')[1])
                                        if not os.path.basename(snp).split('.')[1] in ST[st][vol][intv]:
                                            ST[st][vol][intv][os.path.basename(snp).split('.')[1]] = list()
                                        ST[st][vol][intv][os.path.basename(snp).split('.')[1]].append(os.path.basename(snp))
                        ST[st][vol]['dirlist'] = dirlist
                    #for x in ST[st][vol].keys(): print(x,ST[st][vol][x])
            for st in ST.keys():
                fp = ''
                if args.shortpath == True: fp='/'
                if args.mountpath == True: fp=args.config.getStoreName(st,args.tag)+'/'
                if args.fullpath  == True: fp=args.config.getStorePath(st,args.tag)+'/'
                logger.info('..--==°°==--..')
                #DEBUG('..--==°°==--..',level=1,verbose=args.verbose)
                logger.info('Youngest snapshot in %s' % (st))
                #DEBUG('Youngest snapshot in %s' % (st),level=1,verbose=args.verbose)
                #print("ST",ST[st])
                for vol in ST[st].keys():
                    s = dict()
                    missing = list()
                    logger.info('  Volume %s:' % (vol))
                    #DEBUG('  Volume %s:' % (vol),level=1,verbose=args.verbose)
                    for intv in sorted(ST[st][vol].keys()):
                        #print(ST[st][vol][intv])
                        if intv != 'dirlist':
                            if len(ST[st][vol][intv]) > 0:
                                #for x in sorted(ST[st][vol][intv].keys()): print("Key",x,ST[st][vol][intv],ST[st][vol][intv][x])
                                #i = ST[st][vol][intv].pop()
                                #print("X",ST[st][vol][intv][max(ST[st][vol][intv].keys())])
                                k = max(ST[st][vol][intv].keys())
                                i = ST[st][vol][intv][k]
                                #print("i",intv,i,k)
                                if args.tagset:
                                    if args.all:
                                        #print("A")
                                        s[i.split('.')[1]] = i
                                    else:
                                        #print("B")
                                        s['dirlist'] = ST[st][vol]['dirlist'][sorted(dirlist.keys()).pop()]
                                else:
                                    #print("C",i)
                                    #if i.split('.')[2] == args.tag:
                                        #print("D",i)
                                        #s[i.split('.')[1]] = i
                                    if intv == args.tag:
                                        s[k] = i
                            else:
                                missing.append(intv)

                    lo = 0
                    for i in reversed(sorted(s.keys())):
                        #for j in s[i] if i == 'dirlist' else [s[i]]:
                        for j in s[i]:
                            #out = '»<%s>/  %s%s«' % (st,fp,j)
                            out = '%s%s«' % (fp,j)
                            lo = len(out) if len(out) > lo else lo
                            if args.verbose == 0:
                                logger.info('%s' % (out))
                                #DEBUG('%s' % (out),level=0,verbose=args.verbose)
                            else:
                                logger.info('    %s' % (out))
                                #DEBUG('    %s' % (out),level=1,verbose=args.verbose)
                    logger.info('    %s' % ('-' * (lo)))
                    #DEBUG('    %s' % ('-' * (lo)),level=1,verbose=args.verbose)
                    lo = 0
                    out = """missing: %s""" % (', '.join(missing))

                    if args.tag == 'misc': logger.info("""      %s\n      %s\n""" % (out,'=' * len(out)))
                    #if args.tag == 'misc': DEBUG("""      %s\n      %s\n""" % (out,'=' * len(out)),level=1,verbose=args.verbose)

        if not (args.showyoungest or args.showtransfers or args.showdb or args.showtags or args.showpathstore or args.print_config):
            reintv = re.compile('NEXT|'+'|'.join(args.config.ListIntervals()))
            cmd=['systemctl','list-timers']
            try:
                #output,error = sp_co(self.args,cmd)
                res = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=args.stderr)
                output,error = res.communicate()
                if res.returncode > 0:
                    raise
            except:
                raise
            #if output[0] == 0:
            cut =  120
            for line in output.splitlines():
                l = line.decode()
                if "ACTIVATES" in l:
                    cut = l.find("ACTIVATES")
                    i = l.find("UNIT")
                    print(l[:cut])
                elif reintv.search(l):
                    l = l[:cut]
                    o = l.replace("timer-","").replace(".timer","").rstrip()
                    x = o[i:].rstrip(),
                    print(o+" backup","\t--> transfer" if args.config.getTransfer(x[0]) else "")
            print("--finish--")

    else:
        text = "subvolumes in"
        if args.snap:
            text = "snapshots from"
        elif args.sisters or args.older or args.younger:
            text = "sisters from"
            if args.older:
                text = 'older '+text
            elif args.younger:
                text = 'younger '+text
            else:
                text = 'all '+text
        elif args.tree:
            text = "treeview from"
        elif args.parents:
            text = "parent from"

        for st in args.sourcepath.keys():
            SRC=dict()
            if len(args.snapshots) > 0:
                for snap in args.snapshots:
                    try:
                        SRC[snap]=SubVolume(args,snap,store=st,single=True if args.tree else False)
                        #print('B',SRC[snap].SnapName,snap,st)
                        logger.info("[II]  <%s> is %s" %(st,args.config.getStorePath()))
                        #DEBUG("[II]  <%s> is %s" %(st,args.config.getStorePath()),level=1,verbose=args.verbose)
                        logger.info("[II]  list %s <%s>/%s" %(text,st,SRC[snap].SourceName))
                        #DEBUG("[II]  list %s <%s>/%s" %(text,st,SRC[snap].SourceName),level=1,verbose=args.verbose)
                        fp=''
                        if args.sisters or args.older or args.younger or args.parents or args.snap:
                            if args.shortpath == True: fp='/'
                            if args.mountpath == True: fp=SRC[snap].StoreName+'/'
                            if args.fullpath  == True: fp=SRC[snap].StorePath+'/'
                        else:
                            if args.shortpath == True: fp='/'+SRC[snap].SourceName+'/'
                            if args.mountpath == True: fp=SRC[snap].StoreName+'/'+SRC[snap].SourceName+'/'
                            if args.fullpath  == True: fp=SRC[snap].StorePath+'/'+SRC[snap].SourceName+'/'

                        if args.snap:
                            # List children of snapshot
                            #for i in SRC[snap].list_snapshots(SRC[snap].uuid,rev=args.reverse): print(fp+SRC[snap].SourceName+i)
                            for i in SRC[snap].list_snapshots(SRC[snap].uuid,rev=args.reverse): print(fp+i)
                        elif args.sisters or args.older or args.younger:
                            # List sisters of snapshot (same parent)
                            for i in SRC[snap].list_sisters(SRC[snap].id,rev=args.reverse): print(fp+i)
                        elif args.tree:
                            #print("Treeview of snapshots under %s - in development" % (snap))
                            SRC[snap].build_tree(snap=snap,st=st)
                        elif args.parents:
                            #print("Parentview of snapshots - in development")
                            for i in SRC[snap].list_parent(SRC[snap].puuid): print(fp+i)
                        else:
                            #DEBUG("List subvolumes in given snapshot %s" % (snap),level=1,verbose=args.verbose)
                            for i in SRC[snap].list_subvolumes(SRC[snap].id,rev=args.reverse): print(fp+i)
                    except RuntimeError as e:
                        print(e.args,e.args[1])
                        if e.args[1] == 0:
                            print("list error - nicht so schlimm")
                        else:
                            raise e
                    except (NoSubvolumeError, NoBtrfsVolumeError):
                        print("List Error: <%s>/%s not found -> continue" % (st,snap))
                        pass
                    except ScanFsError:
                        pass
                    except:
                        raise
            else:
                #if args.tree:
                    print("Treeview of snapshots in %s - in development" % (st))
                    SRC['.']=SubVolume(args,'.',store=st,single=True if args.tree else False)
                    SRC['.'].build_tree(snap='.',st=st)

    return

def transfer(args):
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    SRC=dict()
    for snap in args.snapshots:
        try:
            SRC[snap] = SubVolume(args,snap,store=list(args.sourcepath.keys())[0])
            SRC[snap].lock()
            SRC[snap].transfer()
            SRC[snap].unlock(store=list(args.sourcepath.keys())[0])
        except (NoSubvolumeError, NoBtrfsVolumeError):
            #print("Transfer Error: <%s> %s not found -> continue" % (st,snap))
            print("Transfer Error: %s not found -> continue" % (snap))
            pass
        except:
            raise
    cleanup(args)

def restore(args):
    args.mdbsteps = 4 #create, setprop, transfer, cleanup
    args.mdbslice =  100 / 4
    #print('RESTORE FILES', args)
    # if User running "mkbackup restore" is root, set uroot=True
    if os.getuid() == 0:
        uroot = True
    else:
        uroot = False

    if args.no_preserve:
        # If set no_preserve (-n or --no-preserve), create no backup from destination-file
        cpopts=['-b','--suffix=.'+args.timestamp+'.bak']


    for f in args.file:
        #print('restore',os.getcwd(),f,os.path.realpath(f))
        src = Myos().path_realpath(f,args.config.getssh(args.tag,'SRC'))
        bkpsubdir = '/'
        mountp = src
        while mountp > '/':
            cmd=['mountpoint',mountp]
            try:
                res = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=args.stderr)
                output,error = res.communicate()
                if res.returncode > 0:
                    bkpsubdir = mountp
                    mountp = os.path.dirname(mountp)
                else:
                    break
            except:
                raise
        #print(mountp,bkpsubdir,src.replace(bkpsubdir,''))
        mounts = open('/proc/mounts','r')
        R = re.compile(' '+mountp+' ')
        for line in mounts.readlines():
            if R.search(line):
                FS = line.split(' ')[2]
                #print(FS,uroot)
                if FS == "fuse.MksnapshotFS.py":
                    if uroot:
                        dst = src.replace(bkpsubdir,'')
                    else:
                        dst = os.environ['HOME']+src.replace(bkpsubdir,'')
                else:
                    if mountp in [args.config.getMountPath('BKP',args.tag,original=False), args.config.getMountPath('SNP',args.tag,original=False)]:
                        dst = src.replace(bkpsubdir,'')
                        #print(dst)
                    else:
                        dst = ''
                        print('no backup - no restore')
                #print('cp', '-b', '--suffix=.'+args.timestamp+'.bak', src, dst)
                if not args.no_preserve:
                    bkp = dst+'.'+args.timestamp+'.bak~'
                    try:
                        os.rename(dst,bkp)
                    except:
                        print("Destination-file »%s« not existing -> continue" % (dst))
                        pass
                        #raise

                #print('cp',src,dst)
                #print('no copy - do it manually - activate in code')
                try:
                    shutil.copytree(src, dst)
                    print("File restored from %s: %s" % (src,dst))
                except OSError as exc: # python >2.5
                    if exc.errno == errno.ENOTDIR:
                        shutil.copy(src, dst)
                        print("File restored from %s: %s" % (src,dst))
                    else: raise
                #shutil.copy(src,dest)
        mounts.close()

#class desktop_notification:
#    def __init__(self, args, urgency=1):
#        self.args         = args
#        self.dbus_path    = "/at/xundeenergie/notifications"
#        self.dbus_iface   = "at.xundeenergie.notifications.advanced"
#        self.dbus_busname = "at.xundeenergie.notifications"
#        self.timestamp    = datetime.datetime.now()
#        self.time         = self.timestamp.strftime('%H:%M:%S')
#        self.date         = self.timestamp.strftime('%d. %B %Y')
#        self.bus          = dbus.SystemBus()
#        if int(urgency) == 0:
#            self.signal_name  = 'Notification_low'
#        elif int(urgency) == 1:
#            self.signal_name  = 'Notification_normal'
#        else:
#            self.signal_name  = 'Notification_critical'
#        print('NO',int(urgency),self.signal_name)
#
#    def send_signal(self, intv='default', *args):
#        """Send a signal on the bus."""
#        msg = dict()
#        msg['sender'] = "mkbackup"
#        msg['msgheader'] = "%s-backup" % (self.args.tag)
#        msg['msgbody'] = """am %s
#um %s Uhr abgeschlossen.
#
#%s
#(Ugency: %s)
#""" % (self.date, self.time, '\n'.join(args), self.signal_name)
#        msg['expiration_timeout'] = '-1'
#        message = dbus.lowlevel.SignalMessage(self.dbus_path, self.dbus_iface, self.signal_name)
#        message.append(msg)
#        self.bus.send_message(message)

# PARSER

config=Config()

parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version', version='0.1.0')
parser.add_argument('-V', '--systemvolumes', action='store_true',
        default=False, help='''take the systemvolumes from config. store is
        always SNP''')
parser.add_argument('-t', '--tag', default=None, help='''one of %s''' % (config.ListIntervals()))
parser.add_argument('-v', '--verbose', action='count', default=0, help='''verbose output''' )
parser.add_argument('-L', '--logfile', default=None, help='''Write output also to this file in /var/log/''')
#parser.add_argument('-i', '--info', action='store_true', default=False, help='''Print infos, action is "list"''')
parser.add_argument('-i', '--ignore', action='append', help='''Regular expression pattern for ignoring several subvolumes to be not backed up (and subvolumes unter them)
        Use it more than once''')
parser.add_argument('-n', '--no-progressbar', dest='npb', action='store_false', default=True, help='''Dont show progressbar (for use in systemctl-unit for example)''')
parser.add_argument('-B', '--backup-mount-path',
        dest='bkpmount',
        default=config.getMountPath('BKP'),
        help='''set path to destination mountpoint of backup-mountpoint. (default=%s) overrides 'BKP-Path':''' % (config.getMountPath('BKP')))
parser.add_argument('-b', '--backup-store',
        dest='bkpstore',
        default=config.getStoreName('BKP'),
        help='''set storename in backup-mount. (default=%s) overrides 'BKP-Store':''' % (config.getStoreName('BKP')))
parser.add_argument('-S', '--snapshot-mount-path',
        dest='snpmount',
        default=config.getMountPath('SNP'),
        help='''set path to destination mountpoint of snapshot-mountpoint. (default=%s) overrides 'SNP-Path':''' % (config.getMountPath('SNP')))
parser.add_argument('-s', '--snapshot-store',
        dest='snpstore',
        default=config.getStoreName('SNP'),
        help='''set storename in snapshot-mount. (default=%s) overrides 'BKP-Store':''' % (config.getStoreName('SNP')))
parser.add_argument('-N', '--notification', default=None, help='''Send notification. Possible values are "desktop" ''')
parser.add_argument('-U', '--notification_urgency', default=None, help='''Send notification. Possible values are 0=low, 1=normal, 2=critical ''')
#parser.set_defaults(func=main)

subparsers = parser.add_subparsers()

list_parser=subparsers.add_parser('list')
list_parser.add_argument("store",
                        default='SRC',
                        metavar='stores and snapshots',
                        nargs='*',
                        help="""one of SRC, BKP or SNP - where is the snapshot
                        located and one ore more snapshots""")
list_parser.add_argument('-r', '--reverse', action='store_true', default=False)
#list_parser.add_argument('--snap', action='store_true', default=False, help='list snapshots from the queried snapshot')
list_parser.add_argument('-p', '--parents', action='store_true', default=False, help="list parent snapshot from the queried snapshots")
list_parser.add_argument('-S', '--sisters', action='store_true', default=False, help="list snapshots from the queried snapshot with same parent (=sisters)")
list_parser.add_argument('-O', '--older-sisters', action='store_true', dest='older', default=False, help="list snapshots from the queried snapshot with same parent (=sisters) and smaller cgen")
list_parser.add_argument('-Y', '--younger-sisters', action='store_true', dest='younger', default=False, help="list snapshots from the queried snapshot with same parent (=sisters) and bigger cgen")
list_parser.add_argument('-c', '--children', dest='snap', action='store_true', default=False, help="""list snapshots from the queried snapshot""")
list_parser.add_argument('-f', '--fullpath', action='store_true', default=False, help="print full path from /")
list_parser.add_argument('-s', '--shortpath', action='store_true', default=False, help="print path including snapshotname")
list_parser.add_argument('-m', '--mountpath', action='store_true', default=False, help="print path relative to mountpoint of btrfs")
list_parser.add_argument('-i', '--info', dest='info', action='store_true', default=False, help="""Show infos on mkbackup""")
list_parser.add_argument('-P', '--show-StorePath', dest='showpathstore', action='store_true', default=False, help="""Print path of given stores""")
list_parser.add_argument('-t', '--show-tags', dest='showtags', action='store_true', default=False, help="""Print all available tags""")
list_parser.add_argument('-T', '--show-transfers', dest='showtransfers', action='store_true', default=False, help="""Print volumes to transfer by choosen tag""")
list_parser.add_argument('-d', '--show-database', dest='showdb', action='store_true', default=False, help="""Print whole snapshot-database""")
list_parser.add_argument('-y', '--show-youngest', action='store_true', dest='showyoungest', default=False, help="list youngest snapshots in store, with '-t tag' only for this tag")
list_parser.add_argument('--print-config', action='store_true', default=False, help="show the whole configuration or only for the given tag")
list_parser.add_argument('-o', '--outfile', dest='of', default=None, help="print configuration to this file, instead of stdout. Only in combination mit --print-config")
list_parser.add_argument('--all', dest='all', action='store_true', default=False, help="""show full list of all youngest snapshots in all intervals for all volumes (only in combination with -y""")
list_parser.add_argument('--tree', dest='tree', action='store_true', default=False, help="""Build tree from all snapshots (without subvolumes in it)""")
list_parser.set_defaults(func=lists)
list_parser.set_defaults(action='list')

create_parser=subparsers.add_parser('create')
create_parser.add_argument("store",
                        default='SRC',
                        metavar='stores and snapshots',
                        nargs='*',
                        help="""one of SRC or SNP - where is the snapshot located and one ore more snapshots
                        which to be created in the same store.
                        BKP is ignored!!!""")
create_parser.add_argument('--no-clones', action='store_true', default=False, help="""do not use clones for transfer, only parent (if present)""")
create_parser.set_defaults(func=create)
create_parser.set_defaults(action='create')

rollback_parser=subparsers.add_parser('rollback')
rollback_parser.add_argument("store",
                        default='SRC',
                        metavar='stores and snapshots',
                        nargs='*',
                        help="""one of SRC, BKP or SNP - where is the snapshot
                        located and one ore more snapshots""")
rollback_parser.add_argument('--dry-run', action='store_true', default=False, help="show only, do nothing")
rollback_parser.set_defaults(func=rollback)
rollback_parser.set_defaults(action='rollback')

delete_parser=subparsers.add_parser('delete')
delete_parser.add_argument("store",
                        default='SRC',
                        metavar='stores and snapshots',
                        nargs='*',
                        help="""one of SRC, BKP or SNP - where is the snapshot
                        located and one ore more snapshots to be deleted""")
delete_parser.set_defaults(func=delete)
delete_parser.set_defaults(action='delete')

transfer_parser=subparsers.add_parser('transfer')
transfer_parser.add_argument("snapshots",
                        default='SRC',
                        nargs='*',
                        help="""one of SRC or SNP - where is the snapshot located and one ore more snapshots
                        which to be transfered to the external backup-device.
                        BKP is ignored!!!""")
transfer_parser.add_argument('--no-clones', action='store_true', default=False, help="""do not use clones for transfer, only parent (if present)""")
transfer_parser.add_argument('-i', '--info',
        dest='transferinfo',
        action='store_true',
        default=False,
        help="""show only if initial or incremental transfer is done and the parents""")
transfer_parser.set_defaults(func=transfer)
transfer_parser.set_defaults(action='transfer')

cleanup_parser=subparsers.add_parser('cleanup')
cleanup_parser.add_argument("snapshots",
                        nargs='*',
                        help='''cleanup all snapshots, which are older and more
                        than allowed in config''')
cleanup_parser.set_defaults(func=cleanup)
cleanup_parser.set_defaults(action='cleanup')

setprop_parser=subparsers.add_parser('setprop')
setprop_parser.add_argument("store",
                        default='SRC',
                        metavar='stores and snapshots',
                        nargs='*',
                        help='''one of SRC, BKP or SNP - where is the snapshot
                        located and one ore more snapshots''')
setprop_parser.add_argument("-r", "--ro",
                        default=False,
                        action='store_true',
                        help='''setproperty to readonly. If -r is not given,
                        property is set to read-write''')
setprop_parser.set_defaults(func=setprop)
setprop_parser.set_defaults(action='setprop')

restore_parser=subparsers.add_parser('restore')
restore_parser.add_argument("file",
                        nargs='*',
                        help="""restore all given files""")
restore_parser.add_argument("-n", "--no-preserve",
                        default=False,
                        action='store_true',
                        help="""if set, the original file will be overwritten. If not set,
                        the original file is renamed to filename.restore-${TIMESTAMP}""" )
restore_parser.set_defaults(func=restore)
restore_parser.set_defaults(action='restore')



if __name__ == '__main__':
    args = parser.parse_args()
    args.config = config
    args.scriptname = os.path.basename(__file__)
    stores = []
    snapshots = []
#    args.notification = dict()
#    args.notification['bool']=False
#    args.notification['type']=None

    # --- Logger ---
    levels = (logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG, logging.NOTSET)
    #print(logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG, logging.NOTSET)
    print('verbose', args.verbose, levels[args.verbose])
    logger = logging.getLogger(args.scriptname)
    logger.setLevel(logging.DEBUG)
    # create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    # create file handler which logs even debug messages
    # add formatter it to the handlers
    if args.logfile is not None:
        fh = logging.FileHandler('/var/log/'+args.logfile)
        fh.setLevel(logging.DEBUG)
        fh.setFormatter(formatter)
        logger.addHandler(fh)
    # create console handler with a higher log level
    ch = logging.StreamHandler()
    ch.setLevel(levels[args.verbose])
    # create formatter and add it to the handlers
    #ch.setFormatter(formatter)
    # add the handlers to logger
    logger.addHandler(ch)

    # 'application' code
    logger.debug('debug message')
    logger.info('info message')
    logger.warning('warn message')
    logger.error('error message')
    logger.critical('critical message')

    if not 'dry_run' in args:
        args.dry_run=False

    if 'store' in args:
        if isstring(args.store): args.store = args.store.split(' ')
    else:
        args.store = []

    if 'snapshots' in args:
        if isstring(args.snapshots): args.snapshots = args.snapshots.split()
    else:
        args.snapshots = []
    for i in args.store + args.snapshots:
        if i == 'SNP' or i == 'SRC' or i == 'BKP':
            stores.extend([i])
        else:
            snapshots.extend([i.rstrip('/')])
    if len(stores) == 0: stores = ['SRC']

#    if 'notify' in args:
#        args.notification['bool'] = True if args.notify is True else False
#    if 'notify_backend' in args:
#        args.notification['type'] = args.notify_backend



    args.store = stores
    args.snapshots = snapshots

    #print(args.store,args.snapshots)

    # set pathes in config to the given from cmdlin or default
    args.config.setBKPPath(args.bkpmount)
    args.config.setBKPStore(args.bkpstore)
    args.config.setSNPPath(args.snpmount)
    args.config.setSNPStore(args.snpstore)

    # tag = None is not allowed. Set it to misc, if not set
    args.tagset = False
    if args.tag == None:
        args.tag = 'misc'
        args.tagset = True # if no tag was given, and tag is set here, this value is true - it indicates, tag was set automatically to 'misc'


    if args.systemvolumes:
        args.snapshots=args.config.getVolumes(tag=args.tag)
        if len(args.store) == 0: args.store=['SNP']

    # set store and path to store depending on action
    args.sourcepath, args.destpath  = dict(), dict()
    if hasattr(args,'action'):
        if args.action == 'create' or args.action == 'transfer':
            if 'BKP' in args.store: args.store.pop(args.store.index('BKP'))
            args.destpath['BKP'] = args.config.getStorePath('BKP',args.tag)
            if 'SRC' in args.store or 'SNP' not in args.store:
                args.sourcepath['SRC'] = args.config.getStorePath('SRC',args.tag)
            else:
                args.sourcepath['SNP'] = args.config.getStorePath('SNP',args.tag)
        else:
            if len(args.store) == 0:
                args.sourcepath['SRC'] = args.config.getStorePath('SRC',args.tag)
                args.destpath['BKP']   = args.config.getStorePath('BKP',args.tag)
            else:
                for st in args.store:
                    args.sourcepath[st] = args.config.getStorePath(st,args.tag)
                    args.destpath[st]   = args.config.getStorePath(st,args.tag)
        logger.warning('''Action is %s
        Source is %s
        Destination is %s''' % (args.action,args.sourcepath,args.destpath))
    else:
        logger.notset("""Version mkbackup_btrfs_config: %s
Version mkbackup-btrfs: %s
Author: %s""" % (confversion,__version__,__author__))
        quit()

#    DEBUG('SRC',args.sourcepath,level=5,verbose=args.verbose)
#    DEBUG('DST',args.destpath,level=5,verbose=args.verbose)
    logger.debug('SRC',args.sourcepath)
    logger.debug('DST',args.destpath)

    # Set timestamp equal for all operations
    args.ts  = datetime.datetime.now()
    args.timestamp = args.ts.strftime('%Y-%m-%d_%H:%M:%S')
    #args.timestamp    = datetime.datetime.now().strftime('%Y-%m-%d_%H:%M:%S')

    if hasattr(args, 'transferinfo'):
        args.verbose += 1
    else:
        args.transferinfo = False

    # set stdout and stderr for output of subprocess-calls for the verbose-levels
    if args.verbose <= 1:
        args.stdout=subprocess.DEVNULL
        args.stderr=subprocess.DEVNULL
    elif args.verbose <=2:
        args.stdout=subprocess.DEVNULL
        args.stderr=None
    elif args.verbose > 2:
        args.stdout=None
        args.stderr=None

    if args.verbose > 0:
        args.npb = False


    #DEBUG("Arguments",args,verbose=args.verbose)
    if args.verbose > 3:
        logger.debug("Arguments")
        #DEBUG("Arguments",verbose=args.verbose)
        for i in sorted(vars(args)):
            logger.debug(i+': '+str(getattr(args,i,None)))
            #DEBUG(i+': '+str(getattr(args,i,None)),verbose=args.verbose)
    elif args.verbose > 1:
        logger.debug("Arguments")
        #DEBUG("Arguments",args,verbose=args.verbose)

    args.mdbpart = len(args.snapshots ) * len(args.store)
    args.mdb = EmDBUS()
    args.mdb.reset(args.tag)
    args.mdb.start(args.tag)
    #################################################################
    ##                       Run action                            ##
    #################################################################
    args.func(args)


    # Check symlinks in stores, if they exist and ok or missing.
    #for vol in Config().getVolumes():
    for vol in args.config.getVolumes():
        #print("VOL",vol)
        for st in (args.sourcepath.keys()):
            p = args.sourcepath[st]
            #print("P",p,st)
            #for sln in Config().ListSymlinkNames():
            for sln in args.config.ListSymlinkNames():
                link = p+'/'+vol+'.'+sln
                #print("LINK",p,vol,sln,link)
                #print("X",args.tag,st,args.config.ssh[args.tag][st])
                if Myos().path_exists(link,args.config.getssh(args.tag,st)):
                    #print("XX",args.tag,st)
                    if Myos().path_islink(link,args.config.getssh(args.tag,st)):
                        logger.debug("Symlink ok: %s/%s.%s" % (st,vol,sln))
                        #DEBUG("Symlink ok: %s/%s.%s" % (st,vol,sln),level=4,verbose=args.verbose)
                    else:
                        #DEBUG("Symlink broken: %s/%s.%s --> remove it" % (st,vol,sln),level=4,verbose=args.verbose)
                        logger.debug("Symlink broken: %s/%s.%s --> remove it" % (st,vol,sln))
                        Myos(dry=self.args.dry_run).remove(link,args.config.getssh(args.tag,st))
                else:
                    logger.info("Symlink missing: %s/%s.%s" % (st,vol,sln))
                    #DEBUG("Symlink missing: %s/%s.%s" % (st,vol,sln),level=4,verbose=args.verbose)
    for t in args.config.ssh_cons.keys():
        logger.info("Close Connection to %s" % (t))
        #DEBUG("Close Connection to %s" % (t),level=3,verbose=args.verbose)
        try:
            connection = args.config.ssh_cons[t]
            transport = connection.get_transport()
            connection.close()
            transport.send_ignore()
        except:
            # connection is closed
            pass
        logger.info(' -> closed' if args.config.ssh_cons[t].get_transport() == None else 'not closed')
        #DEBUG(' -> closed' if args.config.ssh_cons[t].get_transport() == None else 'not closed', level=3,verbose=args.verbose)
        #args.config.ssh_cons[t].close()
#        for s in args.config.ssh[t].keys():
#            if not args.config.ssh[t][s]['ssh'] == None:
#                print("CLOSE",t,s)
#                args.config.ssh[t][s]['ssh'].close()

    # print summary over all actions
    volumes = list()

    if not args.action == 'list' and not args.action == 'restore':
        logger.info("---=== SUMMARY ===---")
        #DEBUG("---=== SUMMARY ===---",level=0,verbose=args.verbose)
        logger.info("""Stores: %s
snapshots: %s
                """ % (args.store,args.snapshots))
        logger.info("Created Subvolumes:")
        volumes.append('')
        volumes.append('<b>Volumes created:</b>')
        if BtrfsListing.CreatedSubvolumes.is_empty():
            volumes.append('---')
            print('''---
                    ''')
        while not BtrfsListing.CreatedSubvolumes.is_empty():
            i = BtrfsListing.CreatedSubvolumes.pop()
            volumes.append(i[1])
            logger.info(i)
        volumes.append('')

        logger.info("Transfered Subvolumes:")
        volumes.append('<b>Volumes transfered:</b>')
        if BtrfsListing.TransferedSubvolumes.is_empty():
            volumes.append('---')
            print('''---
                    ''')
        while not BtrfsListing.TransferedSubvolumes.is_empty():
            i = BtrfsListing.TransferedSubvolumes.pop()
            volumes.append(i)
            logger.info(i)
        volumes.append('')

        logger.info("Deleted Subvolumes:")
        volumes.append('<b>Volumes deleted:</b>')
        if BtrfsListing.DeletedSubvolumes.is_empty():
            volumes.append('---')
            print(''' ---
                    ''')
        while not BtrfsListing.DeletedSubvolumes.is_empty():
            i = BtrfsListing.DeletedSubvolumes.pop()
            volumes.append(i[1])
            logger.info(i)
        volumes.append('')


    print(args.notification, config.getNotification(intv=args.tag), args.notification_urgency, config.getUrgency(intv=args.tag))
    if args.notification == None:
        args.notification = config.getNotification(intv=args.tag)
    if args.notification_urgency == None:
        args.notification_urgency = config.getUrgency(intv=args.tag)
    print(args.notification, args.notification_urgency)

    if args.notification == 'desktop':
        msg = dict()
        msg['sender'] = "mkbackup"
        msg['header'] = "%s-backup" % (args.tag)
        msg['body'] = """am %s
um %s Uhr abgeschlossen.

%s
http://www.google.com
<a href="file:///home/jakob/backup">TEST</a>
(Ugency: normal)
""" % (args.ts.strftime('%Y-%m-%d'), args.ts.strftime('%H:%M:%S'), '\r'.join(volumes))
#        msg['action'] = dict()
#        msg['action']['action1'] = dict()
#        msg['action']['action1']['title'] = 'Open Backup'
#        msg['action']['action1']['loc'] = 'file:~/backup'


        advnotify = Notification()
        advnotify.normal(msg)
    elif args.notification == None:
        logger.critical("No notification at all")
    else:
        logger.critical("No notification at all")


    logger.critical("---== (%s) finnished %s %s at %s ==---" % (os.getpid(),args.func.__name__, args.tag, args.timestamp))

    args.mdb.finished(args.tag)

#import ntfy

#    import smtplib
#    server = smtplib.SMTP('localhost', 587)
#
#    #Next, log in to the server
#    server.login("username", "verysecret")
#
#    #Send the mail
#    msg = """
#    Hello!""" # The /n separates the message from the headers
#    server.sendmail("first.recipient@provider1.example", "second.recipient@provider2.example", msg)
#

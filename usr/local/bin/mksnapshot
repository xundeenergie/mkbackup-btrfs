#!/usr/bin/python3

import datetime
import signal
import sys
import os
import shlex
import tempfile
#import optparse
import argparse
import subprocess
import re
import configparser
import time

from optparse import OptionParser

import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)

# create a timestamp for all actions
timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H:%M:%S')

def verbose(options,msg):
    if options.verbose:
        print(msg)

def verbose(args, *opts):
    if args.verbosity:
        print(os.path.basename(sys.argv[0]) + ":", *opts, file=sys.stderr)

def warn(*opts):
    print(os.path.basename(sys.argv[0]) + ": warn:", *opts, file=sys.stderr)

def error(*opts):
    print(os.path.basename(sys.argv[0]) + ": error:", *opts, file=sys.stderr)
    sys.exit(3)

def xShell(first, options):
    verbose(options, "%s" % (quote_command(first)))

    p1_stderr = get_stdout(options)
    p1 = subprocess.Popen(first, stdout=subprocess.PIPE, stderr=p1_stderr)
    out, err = p1.communicate()
    return(out.decode('utf8').split('\n'))
    #return(p1.communicate()[0].decode('utf8').split('\n'))
#    p1.stdout.close()
#    r = 0
#    r += check_pipe(first, p1, p1_stderr)
#    if r:
#        sys.exit(r)
#    return(p1)

def pipe(first, second, options):
    verbose(options, "%s | %s" % (quote_command(first), quote_command(second)))

    p1_stderr = get_stdout(options)
    p1 = subprocess.Popen(first, stdout=subprocess.PIPE, stderr=p1_stderr)
    p2_stdout = get_stdout(options)
    p2 = subprocess.Popen(second, stdin=p1.stdout, stdout=p2_stdout, stderr=subprocess.STDOUT)
    p1.stdout.close()
    r = 0
    r += check_pipe(first, p1, p1_stderr)
    r += check_pipe(second, p2, p2_stdout)
    if r:
        sys.exit(r)

def quote_command(command):
    return " ".join(shlex.quote(x) for x in command)

def check_pipe(command, p, errors):
    if p.wait() != 0:
        if errors is None:
            r = ""
        else:
            errors.seek(0)
            r = ": " + errors.read().strip()
        warn(quote_command(command), "failed (%d)%s" % (p.returncode, r))
        return 1
    return 0

def get_stdout(options):
    if options.verbosity > 0:
        return None
    return tempfile.TemporaryFile(mode='w+')

def check_call(command, options):
    verbose(options, quote_command(command))
    stdout = get_stdout(options)
    p = subprocess.Popen(command, stderr=subprocess.STDOUT, stdout=stdout)
    if check_pipe(command, p, stdout) > 0:
        sys.exit(10)

def getsyssubvol():
    return(subprocess.check_output(['/usr/bin/grub-mkrelpath','/'], shell=False).decode('utf8').split("\n")[0].strip("/"))

class Snapshot:
    what = 'Create, list and transfer snapshots from btrfs-Filesystems'

    def __init__(self,options,name,ts=timestamp,tag='misc'):
        self.options = options
        self.config   = Config()
        self.name     = name
        self.parentname = None
        self.bparentname = None
        self.srcsnaps = []
        self.snpsnaps = []
        self.bkpsnaps = []
        self.srcsubs = []
        self.snpsubs = []
        self.bkpsubs = []
        self.gen=None
        self.ogen=None
        self.PUUID=None
        self.UUID=None
        self.RUUID=None
        self.bgen=None
        self.bogen=None
        self.bPUUID=None
        self.bUUID=None
        self.bRUUID=None
        #self.syssubvol = subprocess.check_output(['/usr/bin/grub-mkrelpath','/'], shell=False).decode('utf8').split("\n")[0].strip("/")
        self.syssubvol = getsyssubvol()
        self.btrfs   = '/sbin/btrfs'

        if ts == '':
            self.timestamp = ''
        else:
            self.timestamp = '.'+ts

        if tag == '':
            self.tag = ''
        else:
            self.tag = '.'+tag

    def __get_snapshots(self,store='SRC'):
        verbose(self.options,[store,self.options.parent])
        path = '/'+self.config.getStorePath(store).strip('/')
        verbose(self.options,'Get Snapshots from %s in %s' % (self.name,path))
        gen = None
        ogen = None
        UUID = None
        PUUID = None
        RUUID = None
        parentname = None

        if os.path.exists(path):
            verbose(self.options,path+' existiert')
            so = subprocess.check_output("/sbin/btrfs su li -c -q -p -u -R  --sort=%sogen %s" % ('+',path), shell=True).decode('utf8').strip().split("\n")
            ex = re.compile('.*'+self.name+'$')
            for soline in so:
                sub = soline.partition("path ")[2]
                infos = soline.partition("path ")[0].split(" ")
                if ex.search(sub):
                    gen = infos[3]
                    ogen = infos[5]
                    PUUID = infos[12]
                    RUUID = infos[14]
                    UUID = infos[16]
            if PUUID != None:
                ex = re.compile(PUUID)
                for soline in so:
                    sub = soline.partition("path ")[2]
                    infos = soline.partition("path ")[0].split(" ")
                    if ex.search(infos[16]):
                        parentname = sub

            if store == 'BKP':
                self.bgen = gen
                self.bogen = ogen
                self.bPUUID = PUUID
                self.bRUUID = RUUID
                self.bUUID = UUID
                self.bparentname = parentname
            else:    
                self.gen = gen
                self.ogen = ogen
                self.PUUID = PUUID
                self.RUUID = RUUID
                self.UUID = UUID
                self.parentname = parentname
            
            verbose(self.options,gen,ogen,PUUID,RUUID,UUID )
            if gen == None and ogen == None and PUUID == None and RUUID == None and UUID == None:
                pass
            else:
                opt = ''
                if self.options.parent:
                    if self.options.older:
                        verbose(self.options,"Show older sisters",gen)
                        opt = '-G-%s' % str(int(gen)-1)
                        rexp = PUUID+'$'
                    else:
                        verbose(self.options,"Show all sisters")
                        rexp = PUUID+'$'
                else:
                    if self.options.all:
                        verbose(self.options,"Show Children and source")
                        if PUUID == '-':
                            rexp = UUID
                        else: 
                            rexp = UUID+'|'+PUUID
                        
                    else:
                        verbose(self.options,"Show Children")
                        rexp = UUID+'$'

                if rexp == '-$': rexp = UUID

                so = subprocess.check_output("/sbin/btrfs su li -c -q -p -u -R -o --sort=%sogen %s %s" % ('+',path,opt), shell=True).decode('utf8').strip().split("\n")
                ex = re.compile(rexp)
                for soline in so:
                    sub = soline.partition("path ")[2]
                    infos = soline.partition(" path")[0].split(" ")
                    if self.options.parent:
                        if self.options.older:
                            search = infos[12]
                        else:
                            search = infos[12]
                    else:
                        if self.options.all:
                            search = infos[12]+' '+infos[16]
                        else:
                            search = infos[12]

                    if ex.search(search):
                        if store == 'BKP':
                            if self.bkpsnaps.count([infos,sub]) == 0:
                                self.bkpsnaps.append([infos,sub])
                        else:
                            if self.srcsnaps.count([infos,sub]) == 0:
                                self.srcsnaps.append([infos,sub])
                            if self.snpsnaps.count([infos,sub]) == 0:
                                self.snpsnaps.append([infos,sub])

        else:
            verbose(self.options,path+' existiert nicht')


    def __get_subvolumes(self,store='SRC'):
        path = '/'+self.config.getStorePath(store).strip('/')
        verbose(self.options,'Get Subvolumes from %s in %s' % (self.name,path))
        if os.path.exists(path):
            #print(path+' existiert')
            so = subprocess.check_output("/sbin/btrfs su li -q -p -u -R --sort=%sogen %s" % ('+',path), shell=True).decode('utf8').split("\n")
            ex = re.compile(self.name+'$|'+self.name+'/')
            for soline in so:
                sub = soline.partition("path ")[2]
                infos = soline.partition(" path")[0].split(" ")
                if ex.search(sub):
                    if store == 'SRC' or store == 'SNP':
                        if self.srcsubs.count([infos,sub.replace(self.name,'').strip('/')]) == 0:
                            self.srcsubs.append([infos,sub.replace(self.name,'').strip('/')])
                        if self.snpsubs.count([infos,sub]) == 0:
                            self.snpsubs.append([infos,sub])
                    if store == 'BKP':
                        if self.bkpsubs.count([infos,sub]) == 0:
                            self.bkpsubs.append([infos,sub])
        else:
            pass
            verbose(self.options,path+' existiert nicht')
        #print(self.snpsubs)

    def __transfercheck(self,subvols=False):
        RET = []
        pathSNP = self.config.getStorePath('SNP')
        pathBKP = self.config.getStorePath('BKP')
        #print(pathBKP)
        so = subprocess.check_output("/sbin/btrfs su li -q -p -u -R --sort=%sogen %s" % ('+',pathBKP), shell=True).decode('utf8').split("\n")
        for soline in so:
            sub = soline.partition("path ")[2]
            infos = soline.partition(" path")[0].split(" ")
            if sub != '': bkpsnaps.append([infos,sub])
        if subvols:
            print('Get subvols from %s' % self.name)
            self.__get_snapshots('SNP')
            #self.__get_snapshots('BKP')
            for s in self.snpsnaps:
                for t in self.bkpsnaps:
                    if s[0][16] == t[0][14]:
                        RET.append([s[0][10],s[0][3],s[1]])
        else:
            print('Get snapshots from %s' % self.name)
            self.options.parent = True
            self.options.older = True
            self.__get_snapshots(store='SNP')
            for s in self.snpsnaps:
                for t in bkpsnaps:
                    if s[0][16] == t[0][12]:
                        #print('DONE',s)
                        RET.append([s[0][12],s[0][3],s[1]])
        Out = None
        # Iterate throug Retourlist
        for r in RET:
            # When gen of ret is smaller then gen of the snapshot which should be transfered... 
            if r[1] <= self.gen:
                # Take the youngest snapshot as parent for transfer
                if Out == None:
                    Out = r
                else:
                    if Out[1] < r[1]: Out = r
        return(Out)
        
    def __checkinode(self,path):
            try:
                inode = subprocess.check_output("/usr/bin/stat -c %i " + "%s" % (path), shell=True,stderr=subprocess.DEVNULL).decode('utf8').split("\n")[0]
            except subprocess.CalledProcessError as grepexc:                                                                                                   
                inode = None
            return(inode)

    def TRANSFER(self,options,subvols=False):
        print('Transfer: %s' % (self.name))
        Parent = self.__transfercheck()
        print('PAR',Parent)
        CONF = Config()
        pathSNP = CONF.getStorePath('SNP')
        pathBKP = CONF.getStorePath('BKP')
        transfers = []
        if Parent == None:
            snapshot = self.name
        else:
            snapshot = Parent[2]

        X = Snapshot(self.options,snapshot)
        self.options.parent=False
        for i in X.LIST(store='SNP',sub=True):
            par = '/'+''.join([pathSNP,'/',snapshot,'/',i[1]]).strip('/')
            src = '/'+''.join([pathSNP,'/',self.name,'/',i[1]]).strip('/')
            dst = '/'+''.join([pathBKP,'/',self.name,'/',i[1]]).strip('/')
            dstdir = os.path.dirname(dst)

            if os.path.exists(src):
                inodeSNP = self.__checkinode(src)
                inodePAR = self.__checkinode(par)

                verbose(options,['Xx',inodeSNP,inodePAR])
                if inodeSNP == '256':
                    if inodePAR == '256' and Parent != None:
                            if self.__checkinode(dst) == None:
                                print('Incremental transfer %s => %s' % (os.path.basename(src),dstdir))
                                transfers.append([[options.btrfs,"send",'-p',par,src],[self.btrfs,'receive',dstdir],dst])
                            elif self.__checkinode(dst) == '256': 
                                print('Incr','Ziel als Subvolume vorhanden: %s' % dst)
                                print(" ==> continue")
                                transfers.append(None)
                            else:
                                xShell(['rm','-rf',dst],options)
                                print('Incremental transfer %s => %s' % (os.path.basename(src),dstdir))
                                transfers.append([[options.btrfs,"send",'-p',par,src],[self.btrfs,'receive',dstdir],dst])
                    else:
                            if self.__checkinode(dst) == None:
                                print('Initialtransfer %s => %s' % (os.path.basename(src),dstdir))
                                transfers.append([[options.btrfs, "send",src],[self.btrfs,'receive',dstdir],dst])
                            elif self.__checkinode(dst) == '256': 
                                print('Init:','Ziel als Subvolume vorhanden: %s' % dst)
                                print(" ==> continue")
                                transfers.append(None)
                            else:
                                xShell(['rm','-rf',dst],options)
                                print('Initialtransfer %s => %s' % (os.path.basename(src),dstdir))
                                transfers.append([[options.btrfs, "send",src],[self.btrfs,'receive',dstdir],dst])
                else:
                    verbose(options,'no subvolume, no transfer: %s' % src)
                os.sync()
                if transfers[len(transfers)-1] != None: pipe(transfers[len(transfers)-1][0],transfers[len(transfers)-1][1],options)
                xShell([self.btrfs,'property','set','-ts',dst,'ro','false'],options)

    def CLEANUP(self,options,store='SNP',interval=None):
        cdmin = 0
        chourly = 0
        cdaily = 0
        cweekly = 0
        cmonthly = 0
        cyearly = 0
        cafterboot = 0
        captupgrade = 0
        dmin = self.config.getInterval('dmin')
        hourly = self.config.getInterval('hourly')
        daily = self.config.getInterval('daily')
        weekly = self.config.getInterval('weekly')
        monthly = self.config.getInterval('monthly')
        yearly = self.config.getInterval('yearly')
        afterboot = self.config.getInterval('afterboot')
        aptupgrade = self.config.getInterval('aptupgrade')
        misc = self.config.getInterval('misc')

        path = '/'+self.config.getStorePath(store).strip('/')
        print("Cleanup incomplete snapshots in %s" % (path))
        command = [options.btrfs, "subvol","list","--sort=-gen","-o",path] 
        list = xShell(command,options)
        ex = re.compile('.part$')
        for li in list:
            if ex.search(li):
                sub = li.partition("path ")[2]
                Y = Snapshot(self.options,sub)
                Y.DELETE(store)
        DEL = []
        if options.cleanup or interval==True:
            print("Cleanup interval-snapshots %s in %s" % (self.name,store))
            ilist = ['dmin','hourly','daily','weekly','monthly','yearly','afterboot','apt-upgrade','misc']
            ex = re.compile('$|'.join([self.name+'.*' + word_in_list for word_in_list in ilist])+'$')
            for li in list:
                if ex.search(li):
                    if li.partition('dmin')[1] == 'dmin': 
                        cdmin += 1
                        if cdmin > int(dmin): DEL.append(li.partition('path ')[2])
                    elif li.partition('hourly')[1] == 'hourly': 
                        #print(chourly,int(hourly),li.partition('path')[2])
                        chourly += 1
                        if chourly > int(hourly): DEL.append(li.partition('path ')[2])
                    elif li.partition('daily')[1] == 'daily': 
                        #print(cdaily,int(daily),li.partition('path')[2])
                        cdaily += 1
                        if cdaily > int(daily): DEL.append(li.partition('path ')[2])
                    elif li.partition('weekly')[1] == 'weekly': 
                        cweekly += 1
                        if cweekly > int(weekly): DEL.append(li.partition('path ')[2])
                    elif li.partition('monthly')[1] == 'monthly': 
                        cmonthly += 1
                        if cmonthly > int(monthly): DEL.append(li.partition('path ')[2])
                    elif li.partition('yearly')[1] == 'yearly': 
                        cyearly += 1
                        if cyearly > int(yearly): DEL.append(li.partition('path ')[2])
                    elif li.partition('afterboot')[1] == 'afterboot': 
                        cafterboot += 1
                        if cafterboot > int(afterboot): DEL.append(li.partition('path ')[2])
                    elif li.partition('apt-upgrade')[1] == 'apt-upgrade': 
                        captupgrade += 1
                        if captupgrade > int(dmin): DEL.append(li.partition('path ')[2])
                    elif li.partition('misc')[1] == 'misc': 
                        captupgrade += 1
                        if captupgrade > int(misc): DEL.append(li.partition('path ')[2])

            #print(cdmin,chourly,cdaily,cweekly,cmonthly,cyearly,cafterboot,captupgrade)
            #print(dmin,hourly,daily,weekly,monthly,yearly,afterboot,aptupgrade)
            for d in DEL:
                Y = Snapshot(self.options,d)
                Y.DELETE(store)

    def LIST(self,store='SRC',sub=False,fullpath=False):
        if fullpath: parent=True
        if sub:
            self.__get_subvolumes(store=store)
            if store == 'SRC' or store == 'SNP':
                if self.options.parent:
                    return(self.snpsubs)
                else:
                    return(self.srcsubs)
            elif store == 'BKP':
                return(self.bkpsubs)
        else:
            self.__get_snapshots(store=store)
            if store == 'SRC' or store == 'SNP':
                if self.options.parent:
                   return(self.snpsnaps)
                else:
                    return(self.srcsnaps)
            elif store == 'BKP':
                return(self.bkpsnaps)

    def CREATE(self,options):
        store = 'SNP'
        path = '/'+self.config.getStorePath(store).strip('/')
        self.options.parent=True
        for i in self.LIST(store=store,sub=True,fullpath=True):
            src = path+'/'+i[1]
            dst = path+'/'+i[1].replace(self.name,self.name+self.timestamp+self.tag+'.part')
            print(' =create> '+i[1].replace(self.name,self.name+self.timestamp+self.tag))
            if os.path.exists(dst):
                subprocess.run(['/bin/rm','-r',dst])
                subprocess.CompletedProcess(['/bin/rm','-r',dst],returncode=0)
            subprocess.run(['/sbin/btrfs', 'subvolume', 'snapshot',src,dst],stdout=subprocess.DEVNULL)
            subprocess.CompletedProcess(['/sbin/btrfs subvolume snapshot',src,dst],stdout=subprocess.DEVNULL,returncode=0)
        OLD = self.name.replace(self.name,self.name+self.timestamp+self.tag+'.part')
        NEW = self.name.replace(self.name,self.name+self.timestamp+self.tag)
        X = Snapshot(self.options,OLD)
        X.SETPROP(store=store,ro='true')
        print(' =rename>',path+'/'+OLD,path+'/'+NEW)
        os.rename(path+'/'+OLD,path+'/'+NEW)
        # Cleanup afer each creation deactivated for cron-cleanup-reasons
        if options.cuint: self.CLEANUP(options,interval=True,store=store)
        
        

    def SETPROP(self,store='SRC',ro='false'):
        print('Set %s readonly=%s' % (self.name,ro))
        pathSRC = '/'+self.config.getStorePath(store).strip('/')
        if ro == 'true': 
            self.options.parent=True
            for i in reversed(self.LIST(store=store,sub=True,fullpath=True)):
                print(' =ro> '+pathSRC+'/'+i[1])
                if i[1].split('/')[0] == self.syssubvol or i[1].split('/')[0] == '__ALWAYSCURRENT__': 
                    print("%s ist Systemvolume! Kann nicht auf readonly gesetzt werden!!" % (i[1].split('/')[0]))
                    return("Failure Action on Systemvolume")
                else:
                    LSTRO = ['btrfs', 'property', 'set','-ts',pathSRC+'/'+i[1],'ro',ro]
                    #print(' '.join(LSTRO))
                    subprocess.run(             LSTRO,stdout=subprocess.DEVNULL)
                    subprocess.CompletedProcess(LSTRO,stdout=subprocess.DEVNULL,returncode=0)
        else: 
            self.options.parent = True
            for i in self.LIST(store=store,sub=True,fullpath=True):
                print(' =rw> '+pathSRC+'/'+i[1])
                LSTRO = ['btrfs', 'property', 'set','-ts',pathSRC+'/'+i[1],'ro',ro]
                #print(' '.join(LSTRO))
                subprocess.run(             LSTRO,stdout=subprocess.DEVNULL)
                subprocess.CompletedProcess(LSTRO,stdout=subprocess.DEVNULL,returncode=0)


    def DELETE(self,store='SRC'):
        pathSRC = '/'+self.config.getStorePath(store).strip('/')
        DEL = ['btrfs', 'subvolume', 'delete','-c']
        P = Snapshot(self.options,self.name)
        P.SETPROP(store=store,ro='false')
#        self.SETPROP(store=store,ro='false')
#        self.options.parent = True
        for i in reversed(self.LIST(store=store,sub=True,fullpath=True)):
            print(' =del> '+pathSRC+'/'+i[1])
            if i[1] == self.syssubvol: 
                print("%s ist Systemvolume! Wird nicht gelöscht" % (i))
            else:
                DEL.append(pathSRC+'/'+i[1])
        if len(DEL) > 0:
            subprocess.run(             DEL,stdout=subprocess.DEVNULL)
            subprocess.CompletedProcess(DEL,stdout=subprocess.DEVNULL,returncode=0)


class Config():
    def __init__(self):
        self.cfile = '/etc/mksnapshot.conf'
        self.config = configparser.ConfigParser()
        self.hostname = subprocess.check_output("/bin/hostname",shell=True).decode('utf8').split('\n')[0]
        if os.path.exists(self.cfile): 
            pass #print('OK')
        else:
            print('Default-Config created at %s' % (self.cfile))
            self.CreateConfig()
        self.config.read(self.cfile)
        psrc = os.getcwd()
        if   '/'+psrc.strip('/') == self.config.get('DEFAULT','SNPMNT')+'/'+self.config.get('DEFAULT','snpstore'):
            self.config.set('DEFAULT','SRC', self.config.get('DEFAULT','SNPMNT'))
            self.config.set('DEFAULT','srcstore', self.config.get('DEFAULT','snpstore'))
        elif '/'+psrc.strip('/') == self.config.get('DEFAULT','BKPMNT')+'/'+self.config.get('DEFAULT','bkpstore'):
            self.config.set('DEFAULT','SRC', self.config.get('DEFAULT','BKPMNT'))
            self.config.set('DEFAULT','srcstore', self.config.get('DEFAULT','bkpstore'))
        else:
            self.config.set('DEFAULT','SRC', psrc)
            self.config.set('DEFAULT','srcstore', '')
        
        self.config.read(self.cfile)

    def CreateConfig(self):
        self.config['DEFAULT'] = {'SNPMNT': '/var/cache/btrfs_pool_SYSTEM',
                             'BKPMNT': '/var/cache/backup',
                             'snpstore': '',
                             'bkpstore': self.hostname,
                             'volumes': getsyssubvol()+',__ALWAYSCURRENT__',
                             'interval': 5}
        self.config['INTERVAL'] = {'dmin': 6,
                             'hourly': 24,
                             'daily': 7,
                             'weekly': 52,
                             'monthly': 12,
                             'afterboot': 12,
                             'aptupgrade': 12,
                             'yearly': 7}
        self.config['hourly'] = {'volumes':  getsyssubvol()+',__ALWAYSCURRENT__'}
        self.config['daily'] = {'volumes': getsyssubvol()+',__ALWAYSCURRENT__'}
        self.config['weekly'] = {'volumes': getsyssubvol()+',__ALWAYSCURRENT__'}
        self.config['monthly'] = {'volumes': getsyssubvol()+',__ALWAYSCURRENT__'}
        self.config['yearly'] = {'volumes': getsyssubvol()+',__ALWAYSCURRENT__'}
        self.config['afterboot'] = {'volumes':  getsyssubvol()}
        self.config['aptupgrade'] = {'volumes':  getsyssubvol()}
        self.config['dmin'] = {'volumes': getsyssubvol()+',__ALWAYSCURRENT__'}

        with open(self.cfile, 'w') as configfile:
            try:
                self.config.write(configfile)
            except:
                exit("Failure during creation of config-file")
        return(self.config)

    def ReadConfig(self):
        self.config.read(self.cfile)
        for i in self.config:
            print(i)
            for j in self.config[i]:
                print(j+':',self.config[i][j])

    def getStorePath(self,store='SRC'):
        if store == 'SRC':
            path = '/'+self.config.get('DEFAULT','SRC').strip('/')+'/'+self.config.get('DEFAULT','srcstore').strip('/')
        if store == 'SNP':
            path = '/'+self.config.get('DEFAULT','SNPMNT').strip('/')+'/'+self.__rplst(self.config.get('DEFAULT','snpstore').strip('/'))
        if store == 'BKP':
            path = '/'+self.config.get('DEFAULT','BKPMNT').strip('/')+'/'+self.__rplst(self.config.get('DEFAULT','bkpstore').strip('/'))
        return('/'+path.strip('/'))

    def getMountPath(self,store='SRC'):
        if store == 'SRC':
            path = '/'+self.config.get('DEFAULT','SRC').strip('/')
        if store == 'SNP':
            path = '/'+self.config.get('DEFAULT','SNPMNT').strip('/')
        if store == 'BKP':
            path = '/'+self.config.get('DEFAULT','BKPMNT').strip('/')
        return('/'+path.strip('/'))

    def getInterval(self,intv='misc'):
        try:
            return(self.config.get('INTERVAL',intv))
        except:
            return(self.config.get('DEFAULT','interval'))

    def getVolumes(self,intv='default'):
        try:
            return(self.config.get(intv,'volumes'))
        except:
            return(self.config.get('DEFAULT','volumes'))

    def __rplst(self,store):
        if store == '%h': return(self.hostname)
        else: return(store)

### END CLASSES ##############

def exit_gracefully():
    verbose(options,'OK')

CONF = Config()

usage = """USAGE: %s ACTION [STORE] [options] <snapshots> [<snapshot> [<snapshot]]*

snapshots* = Name(n) der Snapshots, die angezeigt/gelistet oder von denen ein weiterer Snapshot gemacht werden soll.
             Dieser Name ist ohne Pfadangabe und wird jeweils in den Verzeichnissen des "STORE" gesucht.
ACTION     = list|create|delete|transfer
STORE      = [SRC|SNP|BKP]
             SRC = %s (aktuelles Verzeichnis)
             SNP = %s
             BKP = %s
             """ % ('%prog',os.getcwd(),CONF.getStorePath('SNP'),CONF.getStorePath('BKP'))


def main():
    # set session ID to this process so we can kill group in sigterm handle
    #parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser = argparse.ArgumentParser()

    parser.add_argument("-v", "--verbosity", action="count", default=0, help="increase output verbosity")
    parser.add_argument("-V", "--volumes-config", dest="volumes", action="store_true",help="Read volumes to snapshot from configfile")
    parser.add_argument("-s", "--subvolumes", dest="sub", action="store_true", help="List Subvolumes in Snapshot. If False or unset, it lists all the snapshots in the store")
    parser.add_argument("-f", "--full-path", dest="fullpath", default=False, action="store_true",help="Show full pathname on listing")
    parser.add_argument("-d", "--default-volume", dest="syssubvol", default=False, action="store_true",help="Take Snapshot from default-subvolume")
    parser.add_argument("-r", "--reverse", dest="rev", action="store_true", default=False, help="Liste die Snapshots in umgekehrter Reihenfolge")
    parser.add_argument("-t", "--tag", dest="tag", default="misc",help="Tag an den Namen des Subvols anhängen")
    parser.add_argument("-n", "--no-timestamp", action="store_true", dest="ts", default=False, help = "Keinen Timestamp an den Snapshot-Namen anfügen")
    parser.add_argument("-p", "--parent", dest="parent", action="store_true",help="Show snapshots of the parent subvolume")
    parser.add_argument("-c", "--cleanup", dest="cleanup", action="store_true", help="Cleanup before creation of a new Snapshot all broken Snapshots before (*.part)")
    parser.add_argument("-C", "--cleanup-interval", dest="cuint", action="store_true", help="Cleanup old Snapshots from intervals (dmin, hourly, daily...)")
    parser.add_argument("-o", "--show-older", dest="older", action="store_true", help="Show only older snapshots from given one")
    parser.add_argument("-a", "--show-all", dest="all", action="store_true", help="Show given one and children-snapshots")
    parser.add_argument('--btrfs', default="/sbin/btrfs", help='btrfs command')
                                                
    parser.add_argument('args', nargs=argparse.REMAINDER, help='''actions, stores and Snapshots to handle
    actions:\n
        list|create|delete|transfer\n
    stores:\n
        SRC: %s\n
        SNP: %s\n
        BKP: %s\n
    snapshots:\n
        <snapshot1> <snapshot2> <snapshot3>''' % ('A','B','C'))

    options = parser.parse_args()
    verbose(options,options)
    STORES=[]
    SUBVOLS=[]
    CONFIG = Config()

    if len(options.args) == 0:
        sys.exit("zu wenige Argumente")
    else:
        for ar in options.args:
            if ar == 'list':
                ACTION = "LIST"
            elif ar == 'create':
                ACTION = "CREATE"
            elif ar == 'rotate':
                ACTION = "ROTATE"
            elif ar == 'delete':
                ACTION = "DELETE"
            elif ar == 'transfer':
                ACTION = "TRANSFER"
            elif ar == 'setro':
                ACTION = "SETPROP"
                ro = 'true'
            elif ar == 'setrw':
                ACTION = "SETPROP"
            elif ar == 'cleanup':
                ACTION = "CLEANUP"
            elif ar == 'SRC' or ar == 'SNP' or ar == 'BKP':
                STORES.append(ar)
            elif ar == 'mkdefaultconfig':
                ACTION = "CCONFIG"
            elif ar == 'printconfig':
                ACTION = "RCONFIG"
            else:
                SUBVOLS.append(ar.strip("/"))
    #            sys.exit("Argument »%s« wird nicht unterstützt" % (args[ar]))

        if len(STORES) == 0:
            STORES = ['SRC']

#        if len(SUBVOLS) == 0:
#            SUBVOLS.append(getsyssubvol())

        if ACTION == 'LIST':
            verbose(options,'Create listing')
            for store in STORES:
                if options.sub:
                    path = CONFIG.getStorePath(store)
                else:
                    path = CONFIG.getMountPath(store)

                for sub in SUBVOLS:
                    A = Snapshot(options,sub)
                    if options.rev:
                        for i in reversed(A.LIST(store=store,sub=options.sub,fullpath=options.fullpath)):
                            if options.fullpath:
                                print(path+'/'+i[1])
                            else:
                                print(i[1])
                    else:
                        for i in A.LIST(store=store,sub=options.sub,fullpath=options.fullpath):
                            if options.fullpath:
                                print(path+'/'+i[1])
                            else:
                                print(i[1])

        elif ACTION == 'CREATE':
            print(options.cuint)
            if options.volumes:
                if options.tag != "":
                    SUBVOLS = CONFIG.getVolumes(options.tag).split(',')
                else:
                    options.tag = 'misc'
                    SUBVOLS = CONFIG.getVolumes('misc')
            else:
                SUBVOLS.append(getsyssubvol())
                exit("Kein Snapshot zum erstellen ausgewählt")
            store = 'SNP'
            path = CONFIG.getStorePath(store)
            for sub in SUBVOLS:
                A = Snapshot(options,sub,tag=options.tag)
                A.CREATE(options)

        elif ACTION == 'DELETE':
            verbose(options,'Delete Snapshots %s in %s' % (SUBVOLS,STORES))
            if len(SUBVOLS) == 0:
                exit("Nichts zu löschen")
            else:
                for store in STORES:
                    for sub in SUBVOLS:
                        if (store == 'SNP' or store == 'SRC' ) and sub == getsyssubvol():
                            warn("Not able to delete system-subvolume %s" % (sub))
                        else:
                            A = Snapshot(options,sub)
                            A.DELETE(store=store)

        elif ACTION == 'TRANSFER':
            verbose(options,'Transfer Snapshots %s to %s' % (SUBVOLS,'BKP'))
            if len(SUBVOLS) == 0:
                exit("Nothing to transfer")
            else:
                for sub in SUBVOLS:
                    A = Snapshot(options,sub)
                    A.TRANSFER(options)

        elif ACTION == 'CLEANUP':
            if options.volumes:
                if options.tag != "":
                    SUBVOLS = CONFIG.getVolumes(options.tag).split(',')
                else:
                    options.tag = 'misc'
                    SUBVOLS = CONFIG.getVolumes('misc')
            else:
                SUBVOLS.append(getsyssubvol())
                exit("No volume choosen to cleanup")
            for sub in SUBVOLS:
                for store in STORES:
                    verbose(options,'CLEANUP Snapshots from %s in %s' % (sub,store))
                    A = Snapshot(options,sub)
                    A.CLEANUP(options,interval=True,store=store)

        elif ACTION == 'SETPROP':
            if ro == 'false':
                verbose(options,'Set Snapshots to %s %s in %s' % ('READ/WRITE',SUBVOLS,STORES))
            else:
                verbose(options,'Set Snapshots to %s %s in %s' % ('READONLY',SUBVOLS,STORES))

            if len(SUBVOLS) == 0:
                exit("nothing to do")
            else:
                for store in STORES:
                    for sub in SUBVOLS:
                        A = Snapshot(options,sub)
                        A.SETPROP(store=store,ro=ro)

        else:
            print("No further action")

if __name__ == '__main__':
    main()

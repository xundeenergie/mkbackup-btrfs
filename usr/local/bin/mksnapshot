#!/usr/bin/python3 -u

import datetime
import signal
import sys
import os
import errno
import shlex
import tempfile
#import optparse
import argparse
import subprocess
import re
import configparser
import time

from optparse import OptionParser

import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)

# create a timestamp for all actions
timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H:%M:%S')

def verbose(options,msg):
    if options.verbose:
        print(msg)

def verbose(args, *opts):
    if args.verbosity:
        print(os.path.basename(sys.argv[0]) + ":", *opts, file=sys.stderr)

def warn(*opts):
    print(os.path.basename(sys.argv[0]) + ": warn:", *opts, file=sys.stderr)

def error(*opts):
    print(os.path.basename(sys.argv[0]) + ": error:", *opts, file=sys.stderr)
    sys.exit(3)

def xShell(first, options):
    verbose(options, "%s" % (quote_command(first)))

    p1_stderr = get_stdout(options)
    p1 = subprocess.Popen(first, stdout=subprocess.PIPE, stderr=p1_stderr)
    out, err = p1.communicate()
    return(out.decode('utf8').split('\n'))
    #return(p1.communicate()[0].decode('utf8').split('\n'))
#    p1.stdout.close()
#    r = 0
#    r += check_pipe(first, p1, p1_stderr)
#    if r:
#        sys.exit(r)
#    return(p1)

def pipe(first, second, options):
    verbose(options, "%s | %s" % (quote_command(first), quote_command(second)))

    p1_stderr = get_stdout(options)
    p1 = subprocess.Popen(first, stdout=subprocess.PIPE, stderr=p1_stderr)
    p2_stdout = get_stdout(options)
    p2 = subprocess.Popen(second, stdin=p1.stdout, stdout=p2_stdout, stderr=subprocess.STDOUT)
    p1.stdout.close()
    r = 0
    r += check_pipe(first, p1, p1_stderr)
    r += check_pipe(second, p2, p2_stdout)
    if r:
        sys.exit(r)

def quote_command(command):
    return " ".join(shlex.quote(x) for x in command)

def check_pipe(command, p, errors):
    if p.wait() != 0:
        if errors is None:
            r = ""
        else:
            errors.seek(0)
            r = ": " + errors.read().strip()
        warn(quote_command(command), "failed (%d)%s" % (p.returncode, r))
        return 1
    return 0

def get_stdout(options):
    if options.verbosity > 0:
        return None
    return tempfile.TemporaryFile(mode='w+')

def check_call(command, options):
    verbose(options, quote_command(command))
    stdout = get_stdout(options)
    p = subprocess.Popen(command, stderr=subprocess.STDOUT, stdout=stdout)
    if check_pipe(command, p, stdout) > 0:
        sys.exit(10)

def btrfs():
    if os.path.isfile('/sbin/btrfs'):
        prog  = '/sbin/btrfs'
    elif os.path.isfile('/bin/btrfs'):
        prog  = '/bin/btrfs'
    elif os.path.isfile('/usr/bin/btrfs'):
        prog = '/usr/bin/btrfs'
    elif os.path.isfile('/usr/sbin/btrfs'):
        prog = '/usr/sbin/btrfs'
    else:
        exit("btrfs not found")
    return(prog)

def getsyssubvol():
    return(subprocess.check_output(['/usr/bin/grub-mkrelpath','/'], shell=False).decode('utf8').split("\n")[0].strip("/"))

def getyoungest(options,path,sub,tag=''):
    first = [options.btrfs,'sub','list','-co','--sort=-ogen',path]
    if tag == '':
        second = ['grep','-m1',sub+'.']
        ex = re.compile(sub+'.')
    else:
        second = ['grep','m1',sub+'.*'+tag ]
        ex = re.compile(sub+'.*'+tag)
    list = xShell(first,options)
    out = 'A A A 0 A 0'
    for i in list:
        if ex.search(i):
            try:
                if int(i.split()[5]) > int(out.split()[5]): out = i
            except:
                pass
    return(out.partition(' path ')[2])

def cleanup_part(options,store='SNP'):
    # cleanup unfinished snapshots
    path = Config().getMountPath(store)
    verbose(options,"Cleanup incomplete snapshots in %s" % (path))
    command = [options.btrfs, "subvol","list","--sort=-gen","-o",path] 
    list = xShell(command,options)
    ex = re.compile('.part$')
    for li in list:
        if ex.search(li):
            snapshot = li.partition("path ")[2]
            lockfile = "%s.lock~" % (snapshot)
            if os.path.exists(lockfile):
                with open(lockfile, "r") as pidfile:
                    pid = pidfile.read()
                if os.path.exists("/proc/%s" % (pid)):
                    verbose(options,"running: %s %s" % (snapshot,pid))
                else:
                    print(" =delete-part1> ",os.path.basename(snapshot))
                    os.remove(lockfile)
                    Y = Snapshot(options,os.path.basename(snapshot))
                    Y.DELETE(options,store=store)
            else:
                print(" =delete-part2> ",os.path.basename(snapshot))
                #os.remove(lockfile)
                Y = Snapshot(options,os.path.basename(snapshot))
                Y.DELETE(options,store=store)
    dirs = os.listdir( path )
    ex = re.compile('.lock~$')
    for files in dirs:
        if ex.search(files):
            if os.path.exists(path+'/'+files.partition('.lock~')[0]):
                verbose(options,"nodelete %s" % (files))
                pass
            else:
                verbose(options,"delete %s" % (files))
                os.remove(path+'/'+files)
	
	


def symlink_force(target, link_name):
    try:
        os.symlink(target, link_name)
    except OSError as e:
        if e.errno == errno.EEXIST:
            os.remove(link_name)
            os.symlink(target, link_name)
        else:
            raise e

class Snapshot:
    what = 'Create, list and transfer snapshots from btrfs-Filesystems'

    def __init__(self,options,name,ts=timestamp,tag='misc'):
        self.options = options
        self.config   = Config()
        self.name     = name
        self.rawname  = name.split('.')[0]
        self.parentname = None
        self.bparentname = None
        self.srcsnaps = []
        self.snpsnaps = []
        self.bkpsnaps = []
        self.srcsubs = []
        self.snpsubs = []
        self.bkpsubs = []
        self.gen=None
        self.ogen=None
        self.PUUID=None
        self.UUID=None
        self.RUUID=None
        self.bgen=None
        self.bogen=None
        self.bPUUID=None
        self.bUUID=None
        self.bRUUID=None
        #self.syssubvol = subprocess.check_output(['/usr/bin/grub-mkrelpath','/'], shell=False).decode('utf8').split("\n")[0].strip("/")
        self.syssubvol = getsyssubvol()
        self.btrfs = btrfs()

        if ts == '':
            self.timestamp = ''
        else:
            self.timestamp = '.'+ts

        if tag == '':
            self.tag = ''
            self.interval = misc
        else:
            self.tag = '.'+tag
            self.interval = tag

    def __get_snapshots(self,store='SRC'):
        verbose(self.options,[store,self.options.parent])
        path = '/'+self.config.getStorePath(store).strip('/')
        verbose(self.options,'Get Snapshots from %s in %s' % (self.name,path))
        gen = None
        ogen = None
        UUID = None
        PUUID = None
        RUUID = None
        parentname = None

        if os.path.exists(path):
            verbose(self.options,path+' existiert')
            so = subprocess.check_output(self.btrfs + " su li -c -q -p -u -R  --sort=%sogen %s" % ('+',path), shell=True).decode('utf8').strip().split("\n")
            ex = re.compile('.*'+self.name+'$')
            for soline in so:
                sub = soline.partition("path ")[2]
                infos = soline.partition("path ")[0].split(" ")
                if ex.search(sub):
                    gen = infos[3]
                    ogen = infos[5]
                    PUUID = infos[12]
                    RUUID = infos[14]
                    UUID = infos[16]
            if PUUID != None:
                ex = re.compile(PUUID)
                for soline in so:
                    sub = soline.partition("path ")[2]
                    infos = soline.partition("path ")[0].split(" ")
                    if ex.search(infos[16]):
                        parentname = sub

            if store == 'BKP':
                self.bgen = gen
                self.bogen = ogen
                self.bPUUID = PUUID
                self.bRUUID = RUUID
                self.bUUID = UUID
                self.bparentname = parentname
            else:    
                self.gen = gen
                self.ogen = ogen
                self.PUUID = PUUID
                self.RUUID = RUUID
                self.UUID = UUID
                self.parentname = parentname
            
            verbose(self.options,gen,ogen,PUUID,RUUID,UUID )
            if gen == None and ogen == None and PUUID == None and RUUID == None and UUID == None:
                pass
            else:
                opt = ''
                if self.options.parent:
                    if self.options.older:
                        verbose(self.options,"Show older sisters",gen)
                        opt = '-G-%s' % str(int(gen)-1)
                        rexp = PUUID+'$'
                    else:
                        verbose(self.options,"Show all sisters")
                        rexp = PUUID+'$'
                else:
                    if self.options.all:
                        verbose(self.options,"Show Children and source")
                        if PUUID == '-':
                            rexp = UUID
                        else: 
                            rexp = UUID+'|'+PUUID
                        
                    else:
                        verbose(self.options,"Show Children")
                        rexp = UUID+'$'

                if rexp == '-$': rexp = UUID

                so = subprocess.check_output(self.btrfs + " su li -c -q -p -u -R -o --sort=%sogen %s %s" % ('+',path,opt), shell=True).decode('utf8').strip().split("\n")
                ex = re.compile(rexp)
                for soline in so:
                    sub = soline.partition("path ")[2]
                    infos = soline.partition(" path")[0].split(" ")
                    if len(infos) > 1:
                        if self.options.parent:
                            if self.options.older:
                                search = infos[12]
                            else:
                                search = infos[12]
                        else:
                            if self.options.all:
                                search = infos[12]+' '+infos[16]
                            else:
                                search = infos[12]

                        if ex.search(search):
                            if store == 'BKP':
                                if self.bkpsnaps.count([infos,sub]) == 0:
                                    self.bkpsnaps.append([infos,sub])
                            else:
                                if self.srcsnaps.count([infos,sub]) == 0:
                                    self.srcsnaps.append([infos,sub])
                                if self.snpsnaps.count([infos,sub]) == 0:
                                    self.snpsnaps.append([infos,sub])
                    else:
                        pass
                        #print('Nope',infos)

        else:
            verbose(self.options,path+' existiert nicht')


    def __get_subvolumes(self,store='SRC'):
        path = '/'+self.config.getStorePath(store).strip('/')
        verbose(self.options,'Get Subvolumes from %s in %s' % (self.name,path))
        if os.path.exists(path):
            #print(path+' existiert')
            so = subprocess.check_output(self.btrfs + " su li -q -p -u -R --sort=%sogen %s" % ('+',path), shell=True).decode('utf8').split("\n")
            ex = re.compile(self.name+'$|'+self.name+'/')
            for soline in so:
                sub = soline.partition("path ")[2]
                infos = soline.partition(" path")[0].split(" ")
                if ex.search(sub):
                    if store == 'SRC' or store == 'SNP':
                        if self.srcsubs.count([infos,sub.replace(self.name,'').strip('/')]) == 0:
                            self.srcsubs.append([infos,sub.replace(self.name,'').strip('/')])
                        if self.snpsubs.count([infos,sub]) == 0:
                            self.snpsubs.append([infos,sub])
                    if store == 'BKP':
                        if self.bkpsubs.count([infos,sub]) == 0:
                            self.bkpsubs.append([infos,sub])
        else:
            pass
            verbose(self.options,path+' existiert nicht')
        #print(self.snpsubs)

    def __transfercheck(self,subvols=False,parent=True):
        RET = []
        pathSNP = self.config.getStorePath('SNP')
        pathBKP = self.config.getStorePath('BKP')
        bkpsnaps = []
        #print(pathBKP)
        so = subprocess.check_output("%s su li -q -p -u -R --sort=%sogen %s" % (self.btrfs,'+',pathBKP), shell=True).decode('utf8').split("\n")
        for soline in so:
            sub = soline.partition("path ")[2]
            infos = soline.partition(" path")[0].split(" ")
            if sub != '': bkpsnaps.append([infos,sub])
        if subvols:
            print('Get subvols from %s' % self.name)
            self.__get_snapshots('SNP')
            #self.__get_snapshots('BKP')
            for s in self.snpsnaps:
                for t in self.bkpsnaps:
                    if s[0][16] == t[0][14]:
                        RET.append([s[0][10],s[0][3],s[1]])
        else:
            print('Get snapshots from %s' % self.name)
            self.options.parent = True
            self.options.older = True
            self.__get_snapshots(store='SNP')
            for s in self.snpsnaps:
                for t in bkpsnaps:
                    if s[0][16] == t[0][12]:
                        #print('T',t[1])
                        #print(s[0][16],t[0][12],[s[0][12],s[0][3],s[1]])
                        RET.append([s[0][12],s[0][3],s[1],t[1]])
                    else:
                        #print('NOT',s[0][16],t[0][12])
                        pass
        if parent == True:
            Out = None
            # Iterate throug Retourlist
            for r in RET:
                #print(r,self.ogen,self.gen,self.name)
                # When gen of ret is smaller then gen of the snapshot which should be transfered... 
                if int(r[1]) <= int(self.gen):
                    # Take the youngest snapshot as parent for transfer
                    if Out == None:
                        Out = r
                    else:
                        if int(Out[1]) < int(r[1]): Out = r

    #        if len(RET) > 0:
    #            if Out == None:
    #                exit("Snapshot %s is older than initial-transfer" % (self.name))
    #            else:
    #                return(Out)
            #print("OUT: ",Out)
            return(Out)
        else:
            if len(RET) == 0:
                return(None)
            else:
                return(RET)
            
        
    def __checkinode(self,path):
            try:
                inode = subprocess.check_output("/usr/bin/stat -c %i " + "%s" % (path), shell=True,stderr=subprocess.DEVNULL).decode('utf8').split("\n")[0]
            except subprocess.CalledProcessError as grepexc:                                                                                                   
                inode = None
            return(inode)

    def __getinode(self,path):
        cmd = subprocess.Popen('btrfs fi sh %s' % (path), shell=True, stdout=subprocess.PIPE)
        for line in cmd.stdout:
            if "uuid" in str(line):
                return(line.decode('utf8').strip().split()[3])

    def TRANSFER(self,options,subvols=False):
        print('Transfer: %s' % (self.name))

        CONF = Config()
        #path = '/'+self.config.getStorePath(store).strip('/')
        #cleanup_part(options,store='BKP')
        pathSNP = CONF.getStorePath('SNP')
        pathBKP = CONF.getStorePath('BKP')
        mntSNP = CONF.getMountPath('SNP')
        mntBKP = CONF.getMountPath('BKP')
        
        UUID_SNP = self.__getinode(path = mntSNP)
        UUID_BKP = self.__getinode(path = mntBKP)

#        print('S: %s; B: %s' % (UUID_SNP,UUID_BKP))
        ext = False
        if UUID_SNP != '':
            if UUID_BKP != '':
                if UUID_BKP != UUID_SNP:
                    if os.path.exists(pathBKP):
                        #print('OK')
                        ext = True
                        pass
                    else:
                        print('% not existing -> no transfer' % (pathBKP))
                        return()
                else:
                    print('external HD not connected -> no transfer')
                    return()
            else:
                print('external HD not a btrfs-filesystem -> no transfer')
                return()
        else:
            print('internal HD not a btrfs-filesystem -> no transfer')
            return()

        Parents = self.__transfercheck(parent=False)
        try:
            Parent = Parents[len(Parents)-1]
        except:
            Parent = None

        verbose(options,['PAR',Parent])
        
        if os.path.exists(pathBKP+'/'+self.name):
            print("Subvolume »%s« exists --> exit transfer" % (pathBKP+'/'+self.name))
            return() 
            #sys.exit("Subvolume »%s« exists --> exit transfer" % (pathBKP+'/'+self.name))
        if Parent == None:
            #parentsnap = self.name
            parentsnap = self.name 
        else:
            parentsnap = Parent[2]

        X = Snapshot(self.options,self.name)
        self.options.parent=False
        for i in X.LIST(store='SNP',sub=True):
            #print(" Parent:",Parent[2])
            src = '/'+''.join([pathSNP,'/',self.name,'/',i[1]]).strip('/')
            dst = '/'+''.join([pathBKP,'/',self.name,'/',i[1]]).strip('/')
            dstdir = os.path.dirname(dst)
            inodeSNP = self.__checkinode(src)
            inodeDST = self.__checkinode(dst)
            verbose(options,"src",inodeSNP,src)
            verbose(options,"dst",inodeDST,dst)
            verbose(options,"dstdir",dstdir)
            if Parents != None:
                par = '/'+''.join([pathSNP,'/',Parent[2],'/',i[1]]).strip('/')
                dstpar = '/'+''.join([pathBKP,'/',Parent[3],'/',i[1]]).strip('/')
                inodePAR = self.__checkinode(par)
                inodeDSTPAR = self.__checkinode(dstpar)
                verbose(options,"par",inodePAR,par)
                verbose(options,"dstpar",inodeDSTPAR,dstpar)
                for Parent in reversed(Parents):

                    if inodePAR == '256':
                        # Test if there is Parent
                        # If there is a Parent, try incremental Snapshot or Clone
                        if inodeDSTPAR == '256':
                            if inodeDST == None:
                                verbose(options,' ==> transfer')
                                pass
                            elif inodeDST != '256':
                                verbose(options,' - delete directory')
                                os.rmdir(dst)
                            else:
                                print(' exit - subvol exists')
                                verbose(options,'set %s readwrite' % dst)
                                xShell([options.btrfs,'property','set','-ts',dst,'ro','false'],options)
                                break
                            print(' => Incremental transfer »%s« ==> »%s«' % (os.path.basename(src),dstdir), flush=True)
                            os.sync()
                            pipe([options.btrfs,"send",'-p',par,src],[options.btrfs,'receive',dstdir],options)
                            verbose(options,'set »%s« readwrite' % dst)
                            xShell([options.btrfs,'property','set','-ts',dst,'ro','false'],options)
                            break
                        else:
                            print(' -> no destination-parent for »%s« in »%s«, try next' % (os.path.basename(src),Parent[3]))
                            continue
                    else:
                        print(' -> no parent-subvol for »%s« in »%s«, try next' % (os.path.basename(src),Parent[2]))

                else:
                    # If there is no Parent, make initial transfer
                    if inodeDST == None:
                        verbose(options,' ==> transfer')
                        pass
                    elif inodeDST != '256':
                        verbose(options,' - delete directory')
                        os.rmdir(dst)
                    else:
                        print(' exit - subvol exists')
                        verbose(options,'set %s readwrite' % dst)
                        xShell([options.btrfs,'property','set','-ts',dst,'ro','false'],options)
                        break
                    print(' => Initial transfer »%s« ==> »%s«' % (os.path.basename(src),dstdir), flush=True)
                    os.sync()
                    pipe([options.btrfs, "send",src],[options.btrfs,'receive',dstdir],options)
                    verbose(options,'set »%s« readwrite' % dst)
                    xShell([options.btrfs,'property','set','-ts',dst,'ro','false'],options)
            else:
                print(' => Initial transfer »%s« ==> »%s«' % (os.path.basename(src),dstdir), flush=True)
                os.sync()
                pipe([options.btrfs, "send",src],[options.btrfs,'receive',dstdir],options)
                verbose(options,'set »%s« readwrite' % dst)
                xShell([options.btrfs,'property','set','-ts',dst,'ro','false'],options)

	#Create a temporary Symlink and rename it.
        tmpLink = pathBKP+'/tempLnk'
        #linkName = path+'/'+self.name+'.'+self.config.getSymLink(self.interval)
        linkName = pathBKP+'/'+self.rawname+'.CURRENT'
        print(' =symlink>',linkName)
        symlink_force(pathBKP+'/'+self.name.partition('.part')[0],linkName)

        
        if ext == True: self.SETPROP(options,store='BKP',ro='true')
        #print('  Cleanup',options.cuint)
        if options.cuint and ext == True:
            #print('  Cleanup BKP',options.cuint)
            self.CLEANUP(options,interval=True,store='BKP')


    def CLEANUP(self,options,store='SNP',interval=None):
        # Cleanup old, complete snapshots, the count is higher than in config set
        cdmin = 0
        chourly = 0
        cdaily = 0
        cweekly = 0
        cmonthly = 0
        cyearly = 0
        cafterboot = 0
        captupgrade = 0
        cmanually = 0
        cmisc = 0
        dmin = self.config.getInterval('dmin')
        hourly = self.config.getInterval('hourly')
        daily = self.config.getInterval('daily')
        weekly = self.config.getInterval('weekly')
        monthly = self.config.getInterval('monthly')
        yearly = self.config.getInterval('yearly')
        afterboot = self.config.getInterval('afterboot')
        aptupgrade = self.config.getInterval('aptupgrade')
        manually = self.config.getInterval('manually')
        misc = self.config.getInterval('misc')

        path = '/'+self.config.getStorePath(store).strip('/')
#        print("Cleanup incomplete snapshots in %s" % (path))
        command = [options.btrfs, "subvol","list","--sort=-gen","-o",path] 
        list = xShell(command,options)

        DEL = []
        if options.cleanup or interval==True:
            print("Cleanup interval-snapshots from %s in %s" % (self.name,store))
            #ilist = ['dmin','hourly','daily','weekly','monthly','yearly','afterboot','aptupgrade','misc']
            ilist = self.config.ListIntervals()
            verbose(options,ilist)
            ex = re.compile('$|'.join([self.name+'.*' + word_in_list for word_in_list in ilist])+'$')
            for li in list:
                if ex.search(li):
                    if li.partition('dmin')[1] == 'dmin': 
                        cdmin += 1
                        if cdmin > int(dmin): DEL.append(li.partition('path ')[2])
                    elif li.partition('hourly')[1] == 'hourly': 
                        #print(chourly,int(hourly),li.partition('path')[2])
                        chourly += 1
                        if chourly > int(hourly): DEL.append(li.partition('path ')[2])
                    elif li.partition('daily')[1] == 'daily': 
                        #print(cdaily,int(daily),li.partition('path')[2])
                        cdaily += 1
                        if cdaily > int(daily): DEL.append(li.partition('path ')[2])
                    elif li.partition('weekly')[1] == 'weekly': 
                        cweekly += 1
                        if cweekly > int(weekly): DEL.append(li.partition('path ')[2])
                    elif li.partition('monthly')[1] == 'monthly': 
                        cmonthly += 1
                        if cmonthly > int(monthly): DEL.append(li.partition('path ')[2])
                    elif li.partition('yearly')[1] == 'yearly': 
                        cyearly += 1
                        if cyearly > int(yearly): DEL.append(li.partition('path ')[2])
                    elif li.partition('afterboot')[1] == 'afterboot': 
                        cafterboot += 1
                        if cafterboot > int(afterboot): DEL.append(li.partition('path ')[2])
                    elif li.partition('aptupgrade')[1] == 'aptupgrade': 
                        captupgrade += 1
                        if captupgrade > int(dmin): DEL.append(li.partition('path ')[2])
                    elif li.partition('manually')[1] == 'manually': 
                        cmanually += 1
                        if cmanually > int(dmin): DEL.append(li.partition('path ')[2])
                    elif li.partition('misc')[1] == 'misc': 
                        cmisc += 1
                        if cmisc > int(misc): DEL.append(li.partition('path ')[2])

            #print(cdmin,chourly,cdaily,cweekly,cmonthly,cyearly,cafterboot,captupgrade)
            #print(dmin,hourly,daily,weekly,monthly,yearly,afterboot,aptupgrade)
            for d in DEL:
                Y = Snapshot(self.options,os.path.basename(d))
                Y.DELETE(options,store=store)

    def LIST(self,store='SRC',sub=False,fullpath=False):
        if fullpath: parent=True
        if sub:
            self.__get_subvolumes(store=store)
            if store == 'SRC' or store == 'SNP':
                if self.options.parent:
                    return(self.snpsubs)
                else:
                    return(self.srcsubs)
            elif store == 'BKP':
                return(self.bkpsubs)
        else:
            self.__get_snapshots(store=store)
            if store == 'SRC' or store == 'SNP':
                if self.options.parent:
                   return(self.snpsnaps)
                else:
                    return(self.srcsnaps)
            elif store == 'BKP':
                return(self.bkpsnaps)

    def CREATE(self,options):
        store = 'SNP'
        cleanup_part(options,store=store)
        #path = '/'+self.config.getStorePath(store).strip('/')
        path = self.config.getStorePath(store)
        self.options.parent=True
        print(' =lock> ',path+'/'+self.name+self.timestamp+self.tag)
        #print(os.getpid())
        with open(path+'/'+self.name+self.timestamp+self.tag+'.part.lock~', "w") as pidfile:
            pidfile.write(str(os.getpid()))
        #os.mknod(path+'/'+self.name+self.timestamp+self.tag+'.part.lock~')
        for i in self.LIST(store=store,sub=True,fullpath=True):
            src = path+'/'+i[1]
            dst = path+'/'+i[1].replace(self.name,self.name+self.timestamp+self.tag+'.part')
            print(' =create> '+i[1].replace(self.name,self.name+self.timestamp+self.tag))
            if os.path.exists(dst):
                subprocess.call(['/bin/rm','-r',dst])
                #subprocess.CompletedProcess(['/bin/rm','-r',dst],returncode=0)
            verbose(options,self.btrfs)
            subprocess.call([self.btrfs, 'subvolume', 'snapshot',src,dst],stdout=subprocess.DEVNULL)
            #subprocess.CompletedProcess([self.btrfs,'subvolume snapshot',src,dst],stdout=subprocess.DEVNULL,returncode=0)
        OLD = self.name.replace(self.name,self.name+self.timestamp+self.tag+'.part')
        NEW = self.name.replace(self.name,self.name+self.timestamp+self.tag)
        X = Snapshot(self.options,OLD)
        X.SETPROP(options,store=store,ro='true')
        
        # check if transfer is set in configfile
        TR = False
        if options.tag != "":
            TR = Config().getTransfer(options.tag)
            TR = True
            SUBVOLS = Config().getVolumes(options,options.tag,youngest=options.young)
        else:
            options.tag = 'misc'
            TR = Config().getTransfer('misc')
            SUBVOLS = Config().getVolumes(options,'misc',youngest=options.young)

        # do transfer if transfer is set in config an -T on commandline
        if options.transfer and TR and os.path.exists(Config().getStorePath('BKP')):
            cleanup_part(options,store='BKP')
            verbose(options,'Transfer Snapshots %s to %s' % (OLD,'BKP'))
            X.TRANSFER(options)
            #bkppath = '/'+self.config.getStorePath('BKP').strip('/')
            bkppath = self.config.getStorePath('BKP')
            print(' =rename>',bkppath+'/'+OLD,bkppath+'/'+NEW)
            os.rename(bkppath+'/'+OLD,bkppath+'/'+NEW)

        print(' =rename>',path+'/'+OLD,path+'/'+NEW)
        os.rename(path+'/'+OLD,path+'/'+NEW)
	
	#Create a temporary Symlink and rename it.
        tmpLink = path+'/tempLnk'
        linkName = path+'/'+self.name+'.'+self.config.getSymLink(self.interval)
        print(' =symlink>',linkName)
        symlink_force(path+'/'+NEW,linkName)
        #os.rename(tmpLink, linkName)

	#Unlock snapshot
        print(' =unlock> ',path+'/'+self.name+self.timestamp+self.tag)
        os.remove(path+'/'+self.name+self.timestamp+self.tag+'.part.lock~')

        # Cleanup afer each creation deactivated for cron-cleanup-reasons
        #if options.cuint: self.CLEANUP(options,interval=True,store=store)
        if options.cuint:
            self.CLEANUP(options,interval=True,store='SNP')
            self.CLEANUP(options,interval=True,store='BKP')
        

    def SETPROP(self,options,store='SRC',ro='false'):
        verbose(options,'Set %s readonly=%s' % (self.name,ro))
        pathSRC = '/'+self.config.getStorePath(store).strip('/')
        if ro == 'true': 
            self.options.parent=True
            for i in reversed(self.LIST(store=store,sub=True,fullpath=True)):
                print(' =ro> '+pathSRC+'/'+i[1])
                if i[1].split('/')[0] == self.syssubvol or i[1].split('/')[0] == '__ALWAYSCURRENT__': 
                    print("%s is systemvolume! faild to set readonly!!" % (i[1].split('/')[0]))
                    return("Failure - Action on Systemvolume")
                else:
                    LSTRO = ['btrfs', 'property', 'set','-ts',pathSRC+'/'+i[1],'ro',ro]
                    #print(' '.join(LSTRO))
                    subprocess.call(             LSTRO,stdout=subprocess.DEVNULL)
                    #subprocess.CompletedProcess(LSTRO,stdout=subprocess.DEVNULL,returncode=0)
        else: 
            self.options.parent = True
            for i in self.LIST(store=store,sub=True,fullpath=True):
                print(' =rw> '+pathSRC+'/'+i[1])
                LSTRO = ['btrfs', 'property', 'set','-ts',pathSRC+'/'+i[1],'ro',ro]
                #print(' '.join(LSTRO))
                subprocess.call(             LSTRO,stdout=subprocess.DEVNULL)
                #subprocess.CompletedProcess(LSTRO,stdout=subprocess.DEVNULL,returncode=0)


    def DELETE(self,options,store='SRC'):
        pathSRC = '/'+self.config.getStorePath(store).strip('/')
        DEL = ['btrfs', 'subvolume', 'delete','-c']
        P = Snapshot(self.options,self.name)
        P.SETPROP(options,store=store,ro='false')
#        self.SETPROP(store=store,ro='false')
#        self.options.parent = True
        for i in reversed(self.LIST(store=store,sub=True,fullpath=True)):
            print(' =del> '+pathSRC+'/'+i[1])
            if i[1] == self.syssubvol: 
                print("%s is systemvolume! Cannot be deleted!" % (i))
            else:
                DEL.append(pathSRC+'/'+i[1])
        if len(DEL) > 4:
            print('run deleting')
            subprocess.call(             DEL,stdout=subprocess.DEVNULL)
            #subprocess.CompletedProcess(DEL,stdout=subprocess.DEVNULL,returncode=0)
        print('deleting finished')


class Config():
    def __init__(self):
        self.cfile = '/etc/mksnapshot.conf'
        self.config = configparser.ConfigParser()
        self.hostname = subprocess.check_output("/bin/hostname",shell=True).decode('utf8').split('\n')[0]
        if os.path.exists(self.cfile): 
            pass #print('OK')
        else:
            print('Default-Config created at %s' % (self.cfile))
            self.CreateConfig()
        self.config.read(self.cfile)
        psrc = os.getcwd()
        if   '/'+psrc.strip('/') == self.config.get('DEFAULT','SNPMNT')+'/'+self.config.get('DEFAULT','snpstore'):
            self.config.set('DEFAULT','SRC', self.config.get('DEFAULT','SNPMNT'))
            self.config.set('DEFAULT','srcstore', self.config.get('DEFAULT','snpstore'))
        elif '/'+psrc.strip('/') == self.config.get('DEFAULT','BKPMNT')+'/'+self.config.get('DEFAULT','bkpstore'):
            self.config.set('DEFAULT','SRC', self.config.get('DEFAULT','BKPMNT'))
            self.config.set('DEFAULT','srcstore', self.config.get('DEFAULT','bkpstore'))
        else:
            self.config.set('DEFAULT','SRC', psrc)
            self.config.set('DEFAULT','srcstore', '')
        
        self.config.read(self.cfile)

    def CreateConfig(self):
        self.config['DEFAULT'] = {'SNPMNT': '/var/cache/btrfs_pool_SYSTEM',
                             'BKPMNT': '/var/cache/backup',
                             'snpstore': '',
                             'bkpstore': '$h',
                             'volumes': '$S,__ALWAYSCURRENT__',
                             'interval': 5,
                             'symlink': 'LAST',
                             'transfer': False }
        self.config['hourly'] = {'volumes':  '$S,__ALWAYSCURRENT__','interval': '24','transfer': True}
        self.config['daily'] = {'volumes': '$S,__ALWAYSCURRENT__','interval': '7','transfer': True}
        self.config['weekly'] = {'volumes': '$S,__ALWAYSCURRENT__','interval': '5','transfer': True}
        self.config['monthly'] = {'volumes': '$S,__ALWAYSCURRENT__','interval': '12','transfer': True}
        self.config['yearly'] = {'volumes': '$S,__ALWAYSCURRENT__','interval': '7','transfer': True}
        self.config['afterboot'] = {'volumes':  '$S','interval': '4','symlink': 'LASTBOOT'}
        self.config['aptupgrade'] = {'volumes':  '$S','interval': '6','symlink': 'BEFOREUPDATE'}
        self.config['dmin'] = {'volumes': '$S,__ALWAYSCURRENT__','interval': '6'}
        self.config['manually'] = {'volumes': '$S,__ALWAYSCURRENT__','interval': '5','symlink': 'MANUALLY','transfer': True}

        with open(self.cfile, 'w') as configfile:
            try:
                self.config.write(configfile)
            except:
                exit("Failure during creation of config-file")
        return(self.config)

    def ReadConfig(self):
        self.config.read(self.cfile)
        for i in self.config:
            print(i)
            for j in self.config[i]:
                print(j+':',self.config[i][j])

    def ListIntervals(self):
        LST = []
        self.config.read(self.cfile)
        for i in self.config:
            if i != 'DEFAULT':
                LST.append(i) 
            else:
                LST.append('misc')
        return(LST)

    def ListIntervalsFull(self):
        LST = []
        self.config.read(self.cfile)
        for i in self.config:
            if i != 'DEFAULT':
                LST.append(i+': '+str(self.config.get(i,'interval'))) 
            else:
                LST.append('misc: '+str(self.config.get(i,'interval')))
        return(LST)

    def ListSymlinkNames(self):
        LST = []
        self.config.read(self.cfile)
        for i in self.config:
            LST.append(self.config.get(i,'symlink'))
        return(list(set(LST)))


    def getStorePath(self,store='SRC'):
        if store == 'SRC':
            path = '/'+self.config.get('DEFAULT','SRC').strip('/')+'/'+self.config.get('DEFAULT','srcstore').strip('/')
        if store == 'SNP':
            path = '/'+self.config.get('DEFAULT','SNPMNT').strip('/')+'/'+self.__trnName(self.config.get('DEFAULT','snpstore').strip('/'))
        if store == 'BKP':
            path = '/'+self.config.get('DEFAULT','BKPMNT').strip('/')+'/'+self.__trnName(self.config.get('DEFAULT','bkpstore').strip('/'))
        if '/'+path.strip('/') != "/":
            return('/'+path.strip('/'))
        else:
            return(None)

    def getMountPath(self,store='SRC'):
        if store == 'SRC':
            path = '/'+self.config.get('DEFAULT','SRC').strip('/')
        if store == 'SNP':
            path = '/'+self.config.get('DEFAULT','SNPMNT').strip('/')
        if store == 'BKP':
            path = '/'+self.config.get('DEFAULT','BKPMNT').strip('/')
        if '/'+path.strip('/') != "/":
            return('/'+path.strip('/'))
        else:
            return(None)

    def getInterval(self,intv='misc'):
        try:
            return(self.config.get(intv,'interval'))
        except:
            return(self.config.get('DEFAULT','interval'))

    def getTransfer(self,intv='misc'):
        try:
            return(self.config.get(intv,'transfer'))
        except:
            return(self.config.get('DEFAULT','transfer'))

    def getSymLink(self,intv='misc'):
        try:
            return(self.config.get(intv,'symlink'))
        except:
            return(self.config.get('DEFAULT','symlink'))

    def getVolumes(self,options,intv='default',youngest=False):
        VOLSTRANS = []
        try:
            VOLS = self.config.get(intv,'volumes')
        except:
            VOLS = self.config.get('DEFAULT','volumes')
        for vol in VOLS.split(','):
            vol = self.__trnName(vol)
            if youngest:
                verbose(options,'getyoungest from %s' % vol)
                VOLSTRANS.append(getyoungest(options,self.getStorePath('SNP'),vol,tag=options.tag))
            else:
                verbose(options,'notyoungest from %s' % vol)
                VOLSTRANS.append(vol)
        return(VOLSTRANS)

    def ListIntVolumes(self):
        VOLSTRANS = []
        for intv in self.ListIntervals():
            try:
                VOLS = self.config.get(intv,'volumes')
            except:
                VOLS = self.config.get('DEFAULT','volumes')
            VOLS = VOLS.split(',')
            for i, item in enumerate(VOLS):
                VOLS[i] = self.__trnName(item)
#            for vol in VOLS.split(','):
#                vol = self.__trnName(vol)
#                VOLSTRANS.append(vol)
            VOLSTRANS.append('\t'+intv+': '+' '.join(VOLS))
        return(VOLSTRANS)


    def __trnName(self,short):
        if short == "$S": return(getsyssubvol())
        elif short == "$h": return(self.hostname)
        else: return(short)


### END CLASSES ##############

def exit_gracefully():
    verbose(options,'OK')

CONF = Config()

usage = """USAGE: %s [options] ACTION [[STORE] [STORE] [STORE]] <snapshots> [<snapshot> [<snapshot]]*

snapshots* = Name(n) der Snapshots, die angezeigt/gelistet oder von denen ein weiterer Snapshot gemacht werden soll.
             Dieser Name ist ohne Pfadangabe und wird jeweils in den Verzeichnissen des "STORE" gesucht.
ACTION     = list|create|delete|transfer
STORE      = [SRC|SNP|BKP]
             SRC = %s (aktuelles Verzeichnis)
             SNP = %s
             BKP = %s
             """ % ('%prog',os.getcwd(),CONF.getStorePath('SNP'),CONF.getStorePath('BKP'))


def main():
    # set session ID to this process so we can kill group in sigterm handle
    #parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    CONF = Config()

    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument("-v", "--verbosity", action="count", default=0, help="increase output verbosity")
    parser.add_argument("-V", "--volumes-config", dest="volumes", action="store_true",help="Read volumes to snapshot from configfile\n%s" % ('\n'.join(CONF.ListIntVolumes())))
    parser.add_argument("-s", "--subvolumes", dest="sub", action="store_true", help="list - List Subvolumes in Snapshot. If False or unset, it lists all the snapshots in the store")
    #parser.add_argument("--read-only", dest="setro", action="store_false", help="Set snapshot to Read-Only")
    parser.add_argument("-f", "--full-path", dest="fullpath", default=False, action="store_true",help="list - Show full pathname in listing")
    parser.add_argument("-p", "--parent", dest="parent", action="store_true",help="list - Show snapshots of the parent subvolume in listing")
    parser.add_argument("-P", "--get-path", dest="path", action="store_true",help="list - Show path of given store in listing")
    parser.add_argument("-a", "--show-all", dest="all", action="store_true", help="list - Show given one and children-snapshots")
    parser.add_argument("-o", "--show-older", dest="older", action="store_true", help="list - Show only older snapshots from given one")
    parser.add_argument("-r", "--reverse", dest="rev", action="store_true", default=False, help="list - list snapshots in reversed order")
    parser.add_argument("-t", "--tag", dest="tag", default="misc",help="create, list, delete - add tag to subvol-name")
    parser.add_argument("-d", "--default-volume", dest="syssubvol", default=False, action="store_true",help="create - Take Snapshot from default-subvolume")
    parser.add_argument("-n", "--no-timestamp", action="store_true", dest="ts", default=False, help = "create - name snapshot without timestamp")
    parser.add_argument("-c", "--cleanup", dest="cleanup", action="store_true", help="create, cleanup - Cleanup before creation of a new Snapshot all broken Snapshots before (*.part)")
    parser.add_argument("-L", "--create-link", dest="link", action="store_true", help="create - Create symbolic links '%s'" % (' '.join(CONF.ListSymlinkNames())))
    parser.add_argument("-T", "--check-transfer", dest="transfer", action="store_true", help="create - If transfer is choosen as action, this option checks, if transfer is set in configfile")
    parser.add_argument("-y", "--transfer-youngest", dest="young", action="store_true", help="create, cleanup, transfer - search the younges snapshot(s) and transfer ist/them")
    parser.add_argument("-C", "--cleanup-interval", dest="cuint", action="store_true", help="cleanup - Delete old snapshots, wich are higher number than allowed in config for this interval \n\t%s" % ('\n\t'.join(CONF.ListIntervalsFull())))
    parser.add_argument('--btrfs', default=btrfs(), help='/path/to/the/btrfs command')
                                                
    parser.add_argument('args', nargs=argparse.REMAINDER, help='''actions, stores and Snapshots to handle
    actions:
        list|create|delete|transfer|cleanup|setro|setrw
    stores:
        SRC: %s
        SNP: %s
        BKP: %s
    snapshots:
        <snapshot1> <snapshot2> <snapshot3>''' % (os.getcwd(),CONF.getStorePath('SNP'),CONF.getStorePath('BKP')))

    options = parser.parse_args()
    verbose(options,options)
    STORES=[]
    SUBVOLS=[]
    ACTION=[]
    CONFIG = Config()

    if len(options.args) == 0:
        sys.exit("zu wenige Argumente")
    else:
        for ar in options.args:
            if ar == 'list':
                ACTION = "LIST"
            elif ar == 'create':
                ACTION = "CREATE"
            elif ar == 'delete':
                ACTION = "DELETE"
            elif ar == 'transfer':
                ACTION = "TRANSFER"
            elif ar == 'setro':
                ACTION = "SETPROP"
                ro = 'true'
            elif ar == 'setrw':
                ACTION = "SETPROP"
                ro = 'false'
            elif ar == 'cleanup':
                ACTION = "CLEANUP"
            elif ar == 'SRC' or ar == 'SNP' or ar == 'BKP':
                STORES.append(ar)
            elif ar == 'mkdefaultconfig':
                ACTION = "CCONFIG"
            elif ar == 'printconfig':
                ACTION = "RCONFIG"
            else:
                SUBVOLS.append(ar.strip("/"))
    #            sys.exit("Argument »%s« wird nicht unterstützt" % (args[ar]))

        if len(STORES) == 0:
            STORES = ['SRC']

#        if len(SUBVOLS) == 0:
#            SUBVOLS.append(getsyssubvol())

        if len(ACTION) == 0:
            sys.exit("No action defined. Stopping")

        if ACTION == 'LIST':
            verbose(options,'Create listing')
            for store in STORES:
                if options.sub:
                    path = CONFIG.getStorePath(store)
                else:
                    path = CONFIG.getMountPath(store)

                if options.path:
                    print(CONFIG.getStorePath(store))
                elif options.volumes:
                    for x in CONFIG.getVolumes(options,options.tag):
                        print(x)
                else:
                    for sub in SUBVOLS:
                        A = Snapshot(options,sub)
                        if options.rev:
                            for i in reversed(A.LIST(store=store,sub=options.sub,fullpath=options.fullpath)):
                                if options.fullpath:
                                    print(path+'/'+i[1])
                                else:
                                    print(i[1])
                        else:
                            for i in A.LIST(store=store,sub=options.sub,fullpath=options.fullpath):
                                if options.fullpath:
                                    print(path+'/'+i[1])
                                else:
                                    print(i[1])

        elif ACTION == 'CREATE':
            verbose(options,'Create Snapshots from %s' % (SUBVOLS))
            if options.volumes:
                if options.tag != "":
                    SUBVOLS = CONFIG.getVolumes(options,options.tag)
                else:
                    options.tag = 'misc'
                    SUBVOLS = CONFIG.getVolumes(options,'misc')
            else:
                if len(SUBVOLS) == 0:
                    SUBVOLS.append(getsyssubvol())
                    exit("Kein Snapshot zum erstellen ausgewählt")

            store = 'SNP'
            path = CONFIG.getStorePath(store)
            # Do creation of given subvols
            for sub in SUBVOLS:
                #print(sub)
                A = Snapshot(options,sub,tag=options.tag)
                A.CREATE(options)

        elif ACTION == 'DELETE':
            verbose(options,'Delete Snapshots %s in %s' % (SUBVOLS,STORES))
            if len(SUBVOLS) == 0:
                exit("Nichts zu löschen")
            else:
                for store in STORES:
                    for sub in SUBVOLS:
                        if (store == 'SNP' or store == 'SRC' ) and sub == getsyssubvol():
                            warn("Not able to delete system-subvolume %s" % (sub))
                        else:
                            A = Snapshot(options,sub)
                            A.DELETE(options,store=store)

        elif ACTION == 'TRANSFER':
            TR = False
            if options.volumes:
                verbose(options,'Cleanup old interval-snapshots is %s' % (options.cuint))
                if options.tag != "":
                    TR = CONFIG.getTransfer(options.tag)
                    TR = True
                    SUBVOLS = CONFIG.getVolumes(options,options.tag,youngest=options.young)
                else:
                    options.tag = 'misc'
                    TR = CONFIG.getTransfer('misc')
                    SUBVOLS = CONFIG.getVolumes(options,'misc',youngest=options.young)
            else:
                if len(SUBVOLS) == 0:
                    SUBVOLS.append(getsyssubvol())
                    exit("Kein Snapshot zum erstellen ausgewählt")
                else:
                    TR = True

            cleanup_part(options,store='SNP')
            if os.path.isdir(CONFIG.getStorePath('BKP')):
                cleanup_part(options,store='BKP')
                if TR:
                    for sub in SUBVOLS:
                        verbose(options,'Transfer Snapshots %s to %s' % (sub,'BKP'))
                        A = Snapshot(options,sub)
                        A.TRANSFER(options)
                else:
                    exit("No transfer in Config-File for %s-snapshot" % (options.tag))
            else:
                print(CONFIG.getStorePath('BKP'),'nonexistent')
                sys.exit(0) 


        elif ACTION == 'CLEANUP':
            if options.volumes:
                if options.tag != "":
                    SUBVOLS = CONFIG.getVolumes(options,options.tag)
                else:
                    options.tag = 'misc'
                    SUBVOLS = CONFIG.getVolumes(options,'misc')
            else:
                SUBVOLS.append(getsyssubvol())
                for store in STORES:
                    cleanup_part(options,store=store)
                exit("No volume choosen to cleanup")
            for store in STORES:
                cleanup_part(options,store=store)
                for sub in SUBVOLS:
                    verbose(options,'CLEANUP Snapshots from »%s« in »%s«' % (sub,store))
                    A = Snapshot(options,sub)
                    A.CLEANUP(options,interval=True,store=store)

        elif ACTION == 'SETPROP':
            if ro == 'false':
                verbose(options,'Set Snapshots to %s %s in %s' % ('READ/WRITE',SUBVOLS,STORES))
            else:
                verbose(options,'Set Snapshots to %s %s in %s' % ('READONLY',SUBVOLS,STORES))

            if len(SUBVOLS) == 0:
                exit("nothing to do")
            else:
                for store in STORES:
                    for sub in SUBVOLS:
                        A = Snapshot(options,sub)
                        A.SETPROP(options,store=store,ro=ro)

        else:
            print("No further action")

if __name__ == '__main__':
    main()
